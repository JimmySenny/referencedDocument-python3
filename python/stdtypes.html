
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>内置类型 &#8212; Python 3.7.3 文档</title>
    <link rel="stylesheet" href="pydoctheme.css" tppabs="https://docs.python.org/zh-cn/3/_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="pygments.css" tppabs="https://docs.python.org/zh-cn/3/_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="documentation_options.js" tppabs="https://docs.python.org/zh-cn/3/_static/documentation_options.js"></script>
    <script type="text/javascript" src="jquery.js" tppabs="https://docs.python.org/zh-cn/3/_static/jquery.js"></script>
    <script type="text/javascript" src="underscore.js" tppabs="https://docs.python.org/zh-cn/3/_static/underscore.js"></script>
    <script type="text/javascript" src="doctools.js" tppabs="https://docs.python.org/zh-cn/3/_static/doctools.js"></script>
    <script type="text/javascript" src="language_data.js" tppabs="https://docs.python.org/zh-cn/3/_static/language_data.js"></script>
    <script type="text/javascript" src="translations.js" tppabs="https://docs.python.org/zh-cn/3/_static/translations.js"></script>
    
    <script type="text/javascript" src="sidebar.js" tppabs="https://docs.python.org/zh-cn/3/_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.7.3 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="内置异常" href="exceptions.html" />
    <link rel="prev" title="内置常量" href="constants.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/library/stdtypes.html" />
    
    <script type="text/javascript" src="copybutton.js" tppabs="https://docs.python.org/zh-cn/3/_static/copybutton.js"></script>
    <script type="text/javascript" src="switchers.js" tppabs="https://docs.python.org/zh-cn/3/_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" tppabs="https://docs.python.org/zh-cn/3/genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="py-modindex.html" tppabs="https://docs.python.org/zh-cn/3/py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="exceptions.html" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html" title="内置异常"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="constants.html" tppabs="https://docs.python.org/zh-cn/3/library/constants.html" title="内置常量"
             accesskey="P">上一页</a> |</li>
        <li><img src="py.png" tppabs="https://docs.python.org/zh-cn/3/_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="javascript:if(confirm('https://www.python.org/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://www.python.org/'" tppabs="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh_CN</span>
          <span class="version_switcher_placeholder">3.7.3</span>
          <a href="index-11.html" tppabs="https://docs.python.org/zh-cn/3/index.html">文档</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index-2.html" tppabs="https://docs.python.org/zh-cn/3/library/index.html" accesskey="U">Python 标准库</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="https://docs.python.org/zh-cn/3/search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="built-in-types">
<span id="bltin-types"></span><h1>内置类型<a class="headerlink" href="#built-in-types" title="永久链接至标题">¶</a></h1>
<p>以下部分描述了解释器中内置的标准类型。</p>
<p id="index-0">主要内置类型有数字、序列、映射、类、实例和异常。</p>
<p>有些多项集类是可变的。 它们用于添加、移除或重排其成员的方法将原地执行，并不返回特定的项，绝对不会返回多项集实例自身而是返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>有些操作受多种对象类型的支持；特别地，实际上所有对象都可以被比较、检测逻辑值，以及转换为字符串（使用 <a class="reference internal" href="functions.html#repr" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 函数或略有差异的 <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 函数）。 后一个函数是在对象由 <a class="reference internal" href="functions.html#print" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 函数输出时被隐式地调用的。</p>
<div class="section" id="truth-value-testing">
<span id="truth"></span><h2>逻辑值检测<a class="headerlink" href="#truth-value-testing" title="永久链接至标题">¶</a></h2>
<p id="index-1">任何对象都可以进行逻辑值的检测，以便在 <a class="reference internal" href="compound_stmts.html#if" tppabs="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 或 <a class="reference internal" href="compound_stmts.html#while" tppabs="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> 作为条件或是作为下文所述布尔运算的操作数来使用。</p>
<p id="index-2">一个对象在默认情况下均被视为真值，除非当该对象被调用时其所属类定义了 <a class="reference internal" href="datamodel.html#object.__bool__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> 方法且返回 <code class="docutils literal notranslate"><span class="pre">False</span></code> 或是定义了 <a class="reference internal" href="datamodel.html#object.__len__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 方法且返回零。 <a class="footnote-reference" href="#id12" id="id1">[1]</a>  下面基本完整地列出了会被视为假值的内置对象:</p>
<blockquote>
<div></div></blockquote>
<ul class="simple" id="index-3">
<li>被定义为假值的常量: <code class="docutils literal notranslate"><span class="pre">None</span></code> 和 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</li>
<li>任何数值类型的零: <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">0.0</span></code>, <code class="docutils literal notranslate"><span class="pre">0j</span></code>, <code class="docutils literal notranslate"><span class="pre">Decimal(0)</span></code>, <code class="docutils literal notranslate"><span class="pre">Fraction(0,</span> <span class="pre">1)</span></code></li>
<li>空的序列和多项集: <code class="docutils literal notranslate"><span class="pre">''</span></code>, <code class="docutils literal notranslate"><span class="pre">()</span></code>, <code class="docutils literal notranslate"><span class="pre">[]</span></code>, <code class="docutils literal notranslate"><span class="pre">{}</span></code>, <code class="docutils literal notranslate"><span class="pre">set()</span></code>, <code class="docutils literal notranslate"><span class="pre">range(0)</span></code></li>
</ul>
<p id="index-4">产生布尔值结果的运算和内置函数总是返回 <code class="docutils literal notranslate"><span class="pre">0</span></code> 或 <code class="docutils literal notranslate"><span class="pre">False</span></code> 作为假值，<code class="docutils literal notranslate"><span class="pre">1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">True</span></code> 作为真值，除非另行说明。 （重要例外：布尔运算 <code class="docutils literal notranslate"><span class="pre">or</span></code> 和 <code class="docutils literal notranslate"><span class="pre">and</span></code> 总是返回其中一个操作数。）</p>
</div>
<div class="section" id="boolean-operations-and-or-not">
<span id="boolean"></span><h2>布尔运算 --- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code>, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code>, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code><a class="headerlink" href="#boolean-operations-and-or-not" title="永久链接至标题">¶</a></h2>
<p id="index-5">这些属于布尔运算，按优先级升序排列:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="62%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">运算</th>
<th class="head">结果</th>
<th class="head">注释</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code></td>
<td>if <em>x</em> is false, then <em>y</em>, else
<em>x</em></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code></td>
<td>if <em>x</em> is false, then <em>x</em>, else
<em>y</em></td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span></code></td>
<td>if <em>x</em> is false, then <code class="docutils literal notranslate"><span class="pre">True</span></code>,
else <code class="docutils literal notranslate"><span class="pre">False</span></code></td>
<td>(3)</td>
</tr>
</tbody>
</table>
<p id="index-6">注释:</p>
<ol class="arabic simple">
<li>这是个短路运算符，因此只有在第一个参数为假值时才会对第二个参数求值。</li>
<li>这是个短路运算符，因此只有在第一个参数为真值时才会对第二个参数求值。</li>
<li><code class="docutils literal notranslate"><span class="pre">not</span></code> 的优先级比非布尔运算符低，因此 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code> 会被解读为 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">(a</span> <span class="pre">==</span> <span class="pre">b)</span></code> 而 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">not</span> <span class="pre">b</span></code> 会引发语法错误。</li>
</ol>
</div>
<div class="section" id="comparisons">
<span id="stdcomparisons"></span><h2>比较<a class="headerlink" href="#comparisons" title="永久链接至标题">¶</a></h2>
<p id="index-7">在 Python 中有八种比较运算符。 它们的优先级相同（比布尔运算的优先级高）。 比较运算可以任意串连；例如，<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code>，前者的不同之处在于 <em>y</em> 只被求值一次（但在两种情况下当 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> 结果为假值时 <em>z</em> 都不会被求值）。</p>
<p>此表格汇总了比较运算:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">运算</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></td>
<td>严格小于</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code></td>
<td>小于或等于</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></td>
<td>严格大于</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></td>
<td>大于或等于</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">==</span></code></td>
<td>等于</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">!=</span></code></td>
<td>不等于</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">is</span></code></td>
<td>对象标识</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></td>
<td>否定的对象标识</td>
</tr>
</tbody>
</table>
<p id="index-8">除了不同数字类型以外，不同类型的对象比较时绝对不会相等。 而且，某些类型（例如函数对象）仅支持简化比较形式，即任何两个该种类型的对象必定不相等。 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 运算符在以下情况中将引发 <a class="reference internal" href="exceptions.html#TypeError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常：当比较复数与另一个内置数字类型时，当两个对象具有无法被比较的不同类型时，或在未定义次序的其他情况时。</p>
<p id="index-9">具有不同标识的类的实例比较结果通常为不相等，除非类定义了 <a class="reference internal" href="datamodel.html#object.__eq__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 方法。</p>
<p>一个类实例不能与相同类或的其他实例或其他类型的对象进行排序，除非该类定义了足够多的方法，包括 <a class="reference internal" href="datamodel.html#object.__lt__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a>, <a class="reference internal" href="datamodel.html#object.__le__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a>, <a class="reference internal" href="datamodel.html#object.__gt__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> 以及 <a class="reference internal" href="datamodel.html#object.__ge__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> (而如果你想实现常规意义上的比较操作，通常只要有 <a class="reference internal" href="datamodel.html#object.__lt__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> 和 <a class="reference internal" href="datamodel.html#object.__eq__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 就可以了)。</p>
<p><a class="reference internal" href="expressions.html#is" tppabs="https://docs.python.org/zh-cn/3/reference/expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> 和 <a class="reference internal" href="expressions.html#is-not" tppabs="https://docs.python.org/zh-cn/3/reference/expressions.html#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a> 运算符无法自定义；并且它们可以被应用于任意两个对象而不会引发异常。</p>
<p id="index-10">还有两种具有相同语法优先级的运算 <a class="reference internal" href="expressions.html#in" tppabs="https://docs.python.org/zh-cn/3/reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 和 <a class="reference internal" href="expressions.html#not-in" tppabs="https://docs.python.org/zh-cn/3/reference/expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>，它们被 <a class="reference internal" href="glossary.html#term-iterable" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> 或实现了 <a class="reference internal" href="datamodel.html#object.__contains__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> 方法的类型所支持。</p>
</div>
<div class="section" id="numeric-types-int-float-complex">
<span id="typesnumeric"></span><h2>数字类型 --- <a class="reference internal" href="functions.html#int" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#complex" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a><a class="headerlink" href="#numeric-types-int-float-complex" title="永久链接至标题">¶</a></h2>
<p id="index-11">存在三种不同的数字类型: <em class="dfn">整数</em>, <em class="dfn">浮点数</em> 和 <em class="dfn">复数</em>。 此外，布尔值属于整数的子类型。 整数具有无限的精度。 浮点数通常使用 C 中的 <code class="xref c c-type docutils literal notranslate"><span class="pre">double</span></code> 来实现；有关你的程序运行所在机器上浮点数的精度和内部表示法可在 <a class="reference internal" href="sys.html#sys.float_info" tppabs="https://docs.python.org/zh-cn/3/library/sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info</span></code></a> 中查看。 复数包含实部和虚部，分别以一个浮点数表示。 要从一个复数 <em>z</em> 中提取这两个部分，可使用 <code class="docutils literal notranslate"><span class="pre">z.real</span></code> 和 <code class="docutils literal notranslate"><span class="pre">z.imag</span></code>。 （标准库包含附加的数字类型，如表示有理数的 <a class="reference internal" href="fractions.html#module-fractions" tppabs="https://docs.python.org/zh-cn/3/library/fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code></a> 以及以用户定制精度表示浮点数的 <a class="reference internal" href="decimal.html#module-decimal" tppabs="https://docs.python.org/zh-cn/3/library/decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a>。）</p>
<p id="index-12">数字是由数字字面值或内置函数与运算符的结果来创建的。 不带修饰的整数字面值（包括十六进制、八进制和二进制数）会生成整数。 包含小数点或幂运算符的数字字面值会生成浮点数。 在数字字面值末尾加上 <code class="docutils literal notranslate"><span class="pre">'j'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'J'</span></code> 会生成虚数（实部为零的复数），你可以将其与整数或浮点数相加来得到具有实部和虚部的复数。</p>
<p id="index-13">Python 完全支持混合算术：当一个二元运算符用于不同数字类型的操作数时，具有“较窄” 类型的操作数会被扩展为另一个操作数的类型，整数比浮点数更窄，浮点数又比复数更窄。 混合类型数字之间的比较也使用相同的规则。 <a class="footnote-reference" href="#id13" id="id2">[2]</a> 构造器 <a class="reference internal" href="functions.html#int" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="functions.html#float" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> 和 <a class="reference internal" href="functions.html#complex" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> 可被用于生成特定类型的数字。</p>
<p>所有数字类型（复数除外）都支持下列运算，按优先级升序排序（所有数字运算的优先级都高于比较运算）:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="40%" />
<col width="11%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">运算</th>
<th class="head">结果</th>
<th class="head">注释</th>
<th class="head">完整文档</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code></td>
<td><em>x</em> 和 <em>y</em> 的和</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code></td>
<td><em>x</em> 和 <em>y</em> 的差</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code></td>
<td><em>x</em> 和 <em>y</em> 的乘积</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code></td>
<td><em>x</em> 和 <em>y</em> 的商</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">//</span> <span class="pre">y</span></code></td>
<td><em>x</em> 和 <em>y</em> 的商数</td>
<td>(1)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code></td>
<td>remainder of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code></td>
<td>(2)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">-x</span></code></td>
<td><em>x</em> 取反</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">+x</span></code></td>
<td><em>x</em> 不变</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">abs(x)</span></code></td>
<td><em>x</em> 的绝对值或大小</td>
<td>&#160;</td>
<td><a class="reference internal" href="functions.html#abs" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">int(x)</span></code></td>
<td>将 <em>x</em> 转换为整数</td>
<td>(3)(6)</td>
<td><a class="reference internal" href="functions.html#int" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">float(x)</span></code></td>
<td>将 <em>x</em> 转换为浮点数</td>
<td>(4)(6)</td>
<td><a class="reference internal" href="functions.html#float" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">complex(re,</span> <span class="pre">im)</span></code></td>
<td>一个带有实部 <em>re</em> 和虚部 <em>im</em> 的复数。<em>im</em> 默认为0。</td>
<td>(6)</td>
<td><a class="reference internal" href="functions.html#complex" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">c.conjugate()</span></code></td>
<td>复数 <em>c</em> 的共轭</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">divmod(x,</span> <span class="pre">y)</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y,</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y)</span></code></td>
<td>(2)</td>
<td><a class="reference internal" href="functions.html#divmod" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">y)</span></code></td>
<td><em>x</em> 的 <em>y</em> 次幂</td>
<td>(5)</td>
<td><a class="reference internal" href="functions.html#pow" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">y</span></code></td>
<td><em>x</em> 的 <em>y</em> 次幂</td>
<td>(5)</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p id="index-14">注释:</p>
<ol class="arabic">
<li><p class="first">也称为整数除法。 结果值是一个整数，但结果的类型不一定是 int。 运算结果总是向负无穷的方向舍入: <code class="docutils literal notranslate"><span class="pre">1//2</span></code> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">(-1)//2</span></code> 为 <code class="docutils literal notranslate"><span class="pre">-1</span></code>, <code class="docutils literal notranslate"><span class="pre">1//(-2)</span></code> 为 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 而 <code class="docutils literal notranslate"><span class="pre">(-1)//(-2)</span></code> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
</li>
<li><p class="first">不可用于复数。 而应在适当条件下使用 <a class="reference internal" href="functions.html#abs" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> 转换为浮点数。</p>
</li>
<li><p id="index-15">从浮点数转换为整数会被舍入或是像在 C 语言中一样被截断；请参阅 <a class="reference internal" href="math.html#math.floor" tppabs="https://docs.python.org/zh-cn/3/library/math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.floor()</span></code></a> 和 <a class="reference internal" href="math.html#math.ceil" tppabs="https://docs.python.org/zh-cn/3/library/math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.ceil()</span></code></a> 函数查看转换的完整定义。</p>
</li>
<li><p class="first">float 也接受字符串 &quot;nan&quot; 和附带可选前缀 &quot;+&quot; 或 &quot;-&quot; 的 &quot;inf&quot; 分别表示非数字 (NaN) 以及正或负无穷。</p>
</li>
<li><p class="first">Python 将 <code class="docutils literal notranslate"><span class="pre">pow(0,</span> <span class="pre">0)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">**</span> <span class="pre">0</span></code> 定义为 <code class="docutils literal notranslate"><span class="pre">1</span></code>，这是编程语言的普遍做法。</p>
</li>
<li><p class="first">接受的数字字面值包括数码 <code class="docutils literal notranslate"><span class="pre">0</span></code> 到 <code class="docutils literal notranslate"><span class="pre">9</span></code> 或任何等效的 Unicode 字符（具有 <code class="docutils literal notranslate"><span class="pre">Nd</span></code> 特征属性的代码点）。</p>
<p>请参阅 <a class="reference external" href="javascript:if(confirm('http://www.unicode.org/Public/10.0.0/ucd/extracted/issue19500  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.unicode.org/Public/10.0.0/ucd/extracted/issue19500'" tppabs="http://www.unicode.org/Public/10.0.0/ucd/extracted/DerivedNumericType.txt">http://www.unicode.org/Public/10.0.0/ucd/extracted/DerivedNumericType.txt</a> 查看具有 <code class="docutils literal notranslate"><span class="pre">Nd</span></code> 特征属性的代码点的完整列表。</p>
</li>
</ol>
<p>所有 <a class="reference internal" href="numbers.html#numbers.Real" tppabs="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code></a> 类型 (<a class="reference internal" href="functions.html#int" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 和 <a class="reference internal" href="functions.html#float" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) 还包括下列运算:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">运算</th>
<th class="head">结果</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="math.html#math.trunc" tppabs="https://docs.python.org/zh-cn/3/library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.trunc(x)</span></code></a></td>
<td><em>x</em> 截断为 <a class="reference internal" href="numbers.html#numbers.Integral" tppabs="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="functions.html#round" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round(x[,</span>
<span class="pre">n])</span></code></a></td>
<td><em>x</em> 舍入到 <em>n</em> 位小数，半数值会舍入到偶数。 如果省略 <em>n</em>，则默认为 0。</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="math.html#math.floor" tppabs="https://docs.python.org/zh-cn/3/library/math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.floor(x)</span></code></a></td>
<td>&lt;= <em>x</em> 的最大 <a class="reference internal" href="numbers.html#numbers.Integral" tppabs="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="math.html#math.ceil" tppabs="https://docs.python.org/zh-cn/3/library/math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.ceil(x)</span></code></a></td>
<td>&gt;= <em>x</em> 的最小 <a class="reference internal" href="numbers.html#numbers.Integral" tppabs="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a></td>
</tr>
</tbody>
</table>
<p>有关更多的数字运算请参阅 <a class="reference internal" href="math.html#module-math" tppabs="https://docs.python.org/zh-cn/3/library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 和 <a class="reference internal" href="cmath.html#module-cmath" tppabs="https://docs.python.org/zh-cn/3/library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a> 模块。</p>
<div class="section" id="bitwise-operations-on-integer-types">
<span id="bitstring-ops"></span><h3>整数类型的按位运算<a class="headerlink" href="#bitwise-operations-on-integer-types" title="永久链接至标题">¶</a></h3>
<p id="index-16">按位运算只对整数有意义。 计算按位运算的结果，就相当于使用无穷多个二进制符号位对二的补码执行操作。</p>
<p>二进制按位运算的优先级全都低于数字运算，但又高于比较运算；一元运算 <code class="docutils literal notranslate"><span class="pre">~</span></code> 具有与其他一元算术运算 (<code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code>) 相同的优先级。</p>
<p>此表格是以优先级升序排序的按位运算列表:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="59%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">运算</th>
<th class="head">结果</th>
<th class="head">注释</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">|</span> <span class="pre">y</span></code></td>
<td><em>x</em> 和 <em>y</em> 按位 <em class="dfn">或</em></td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">^</span> <span class="pre">y</span></code></td>
<td><em>x</em> 和 <em>y</em> 按位 <em class="dfn">异或</em></td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&amp;</span> <span class="pre">y</span></code></td>
<td><em>x</em> 和 <em>y</em> 按位 <em class="dfn">与</em></td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">n</span></code></td>
<td><em>x</em> 左移 <em>n</em> 位</td>
<td>(1)(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">n</span></code></td>
<td><em>x</em> 右移 <em>n</em> 位</td>
<td>(1)(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">~x</span></code></td>
<td><em>x</em> 逐位取反</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>注释:</p>
<ol class="arabic simple">
<li>负的移位数是非法的，会导致引发 <a class="reference internal" href="exceptions.html#ValueError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</li>
<li>左移 <em>n</em> 位等价于不带溢出检测地乘以 <code class="docutils literal notranslate"><span class="pre">pow(2,</span> <span class="pre">n)</span></code>。</li>
<li>右移 <em>n</em> 位等价于不带溢出检测地除以 <code class="docutils literal notranslate"><span class="pre">pow(2,</span> <span class="pre">n)</span></code>。</li>
<li>使用带有至少一个额外符号扩展位的有限个二进制补码表示（有效位宽度为 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">max(x.bit_length(),</span> <span class="pre">y.bit_length())</span></code> 或以上）执行这些计算就足以获得相当于有无数个符号位时的同样结果。</li>
</ol>
</div>
<div class="section" id="additional-methods-on-integer-types">
<h3>整数类型的附加方法<a class="headerlink" href="#additional-methods-on-integer-types" title="永久链接至标题">¶</a></h3>
<p>int 类型实现了 <a class="reference internal" href="numbers.html#numbers.Integral" tppabs="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a> <a class="reference internal" href="glossary.html#term-abstract-base-class" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>。 此外，它还提供了其他几个方法:</p>
<dl class="method">
<dt id="int.bit_length">
<code class="descclassname">int.</code><code class="descname">bit_length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#int.bit_length" title="永久链接至目标">¶</a></dt>
<dd><p>返回以二进制表示一个整数所需要的位数，不包括符号位和前面的零:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">&#39;-0b100101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<p>更准确地说，如果 <code class="docutils literal notranslate"><span class="pre">x</span></code> 非零，则 <code class="docutils literal notranslate"><span class="pre">x.bit_length()</span></code> 是使得 <code class="docutils literal notranslate"><span class="pre">2**(k-1)</span> <span class="pre">&lt;=</span> <span class="pre">abs(x)</span> <span class="pre">&lt;</span> <span class="pre">2**k</span></code> 的唯一正整数 <code class="docutils literal notranslate"><span class="pre">k</span></code>。 同样地，当 <code class="docutils literal notranslate"><span class="pre">abs(x)</span></code> 小到足以具有正确的舍入对数时，则 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">int(log(abs(x),</span> <span class="pre">2))</span></code>。 如果 <code class="docutils literal notranslate"><span class="pre">x</span></code> 为零，则 <code class="docutils literal notranslate"><span class="pre">x.bit_length()</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
<p>等价于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bit_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>       <span class="c1"># binary representation:  bin(-37) --&gt; &#39;-0b100101&#39;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;-0b&#39;</span><span class="p">)</span> <span class="c1"># remove leading zeros and minus sign</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>       <span class="c1"># len(&#39;100101&#39;) --&gt; 6</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="int.to_bytes">
<code class="descclassname">int.</code><code class="descname">to_bytes</code><span class="sig-paren">(</span><em>length</em>, <em>byteorder</em>, <em>*</em>, <em>signed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#int.to_bytes" title="永久链接至目标">¶</a></dt>
<dd><p>返回表示一个整数的字节数组。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x04\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">b&#39;\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;little&#39;</span><span class="p">)</span>
<span class="go">b&#39;\xe8\x03&#39;</span>
</pre></div>
</div>
<p>整数会使用 <em>length</em> 个字节来表示。 如果整数不能用给定的字节数来表示则会引发 <a class="reference internal" href="exceptions.html#OverflowError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。</p>
<p><em>byteorder</em> 参数确定用于表示整数的字节顺序。 如果 <em>byteorder</em> 为 <code class="docutils literal notranslate"><span class="pre">&quot;big&quot;</span></code>，则最高位字节放在字节数组的开头。 如果 <em>byteorder</em> 为 <code class="docutils literal notranslate"><span class="pre">&quot;little&quot;</span></code>，则最高位字节放在字节数组的末尾。 要请求主机系统上的原生字节顺序，请使用 <a class="reference internal" href="sys.html#sys.byteorder" tppabs="https://docs.python.org/zh-cn/3/library/sys.html#sys.byteorder" title="sys.byteorder"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.byteorder</span></code></a> 作为字节顺序值。</p>
<p><em>signed</em> 参数确定是否使用二的补码来表示整数。 如果 <em>signed</em> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 并且给出的是负整数，则会引发 <a class="reference internal" href="exceptions.html#OverflowError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。 <em>signed</em> 的默认值为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="int.from_bytes">
<em class="property">classmethod </em><code class="descclassname">int.</code><code class="descname">from_bytes</code><span class="sig-paren">(</span><em>bytes</em>, <em>byteorder</em>, <em>*</em>, <em>signed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#int.from_bytes" title="永久链接至目标">¶</a></dt>
<dd><p>返回由给定字节数组所表示的整数。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x10</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x10</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;little&#39;</span><span class="p">)</span>
<span class="go">4096</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xfc\x00</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">-1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xfc\x00</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">64512</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">([</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">16711680</span>
</pre></div>
</div>
<p><em>bytes</em> 参数必须为一个 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 或是生成字节的可迭代对象。</p>
<p><em>byteorder</em> 参数确定用于表示整数的字节顺序。 如果 <em>byteorder</em> 为 <code class="docutils literal notranslate"><span class="pre">&quot;big&quot;</span></code>，则最高位字节放在字节数组的开头。 如果 <em>byteorder</em> 为 <code class="docutils literal notranslate"><span class="pre">&quot;little&quot;</span></code>，则最高位字节放在字节数组的末尾。 要请求主机系统上的原生字节顺序，请使用 <a class="reference internal" href="sys.html#sys.byteorder" tppabs="https://docs.python.org/zh-cn/3/library/sys.html#sys.byteorder" title="sys.byteorder"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.byteorder</span></code></a> 作为字节顺序值。</p>
<p><em>signed</em> 参数指明是否使用二的补码来表示整数。</p>
<div class="versionadded">
<p><span class="versionmodified">3.2 新版功能.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="additional-methods-on-float">
<h3>浮点类型的附加方法<a class="headerlink" href="#additional-methods-on-float" title="永久链接至标题">¶</a></h3>
<p>float 类型实现了 <a class="reference internal" href="numbers.html#numbers.Real" tppabs="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code></a> <a class="reference internal" href="glossary.html#term-abstract-base-class" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>。 float 还具有以下附加方法。</p>
<dl class="method">
<dt id="float.as_integer_ratio">
<code class="descclassname">float.</code><code class="descname">as_integer_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.as_integer_ratio" title="永久链接至目标">¶</a></dt>
<dd><p>返回一对整数，其比率正好等于原浮点数并且分母为正数。 无穷大会引发 <a class="reference internal" href="exceptions.html#OverflowError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> 而 NaN 则会引发 <a class="reference internal" href="exceptions.html#ValueError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
</dd></dl>

<dl class="method">
<dt id="float.is_integer">
<code class="descclassname">float.</code><code class="descname">is_integer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.is_integer" title="永久链接至目标">¶</a></dt>
<dd><p>如果 float 实例可用有限位整数表示则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<p>两个方法均支持与十六进制数字符串之间的转换。 由于 Python 浮点数在内部存储为二进制数，因此浮点数与 <em>十进制数</em> 字符串之间的转换往往会导致微小的舍入错误。 而十六进制数字符串却允许精确地表示和描述浮点数。 这在进行调试和数值工作时非常有用。</p>
<dl class="method">
<dt id="float.hex">
<code class="descclassname">float.</code><code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.hex" title="永久链接至目标">¶</a></dt>
<dd><p>以十六进制字符串的形式返回一个浮点数表示。 对于有限浮点数，这种表示法将总是包含前导的 <code class="docutils literal notranslate"><span class="pre">0x</span></code> 和尾随的 <code class="docutils literal notranslate"><span class="pre">p</span></code> 加指数。</p>
</dd></dl>

<dl class="classmethod">
<dt id="float.fromhex">
<em class="property">classmethod </em><code class="descclassname">float.</code><code class="descname">fromhex</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#float.fromhex" title="永久链接至目标">¶</a></dt>
<dd><p>返回以十六进制字符串 <em>s</em> 表示的浮点数的类方法。 字符串 <em>s</em> 可以带有前导和尾随的空格。</p>
</dd></dl>

<p>请注意 <a class="reference internal" href="#float.hex" title="float.hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">float.hex()</span></code></a> 是实例方法，而 <a class="reference internal" href="#float.fromhex" title="float.fromhex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">float.fromhex()</span></code></a> 是类方法。</p>
<p>十六进制字符串采用的形式为:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="p">[</span><span class="s1">&#39;0x&#39;</span><span class="p">]</span> <span class="n">integer</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span> <span class="n">fraction</span><span class="p">]</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span> <span class="n">exponent</span><span class="p">]</span>
</pre></div>
</div>
<p>可选的 <code class="docutils literal notranslate"><span class="pre">sign</span></code> 可以是 <code class="docutils literal notranslate"><span class="pre">+</span></code> 或 <code class="docutils literal notranslate"><span class="pre">-</span></code>，<code class="docutils literal notranslate"><span class="pre">integer</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fraction</span></code> 是十六进制数码组成的字符串，<code class="docutils literal notranslate"><span class="pre">exponent</span></code> 是带有可选前导符的十进制整数。 大小写没有影响，在 integer 或 fraction 中必须至少有一个十六进制数码。 此语法类似于 C99 标准的 6.4.4.2 小节中所描述的语法，也是 Java 1.5 以上所使用的语法。 特别地，<a class="reference internal" href="#float.hex" title="float.hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">float.hex()</span></code></a> 的输出可以用作 C 或 Java 代码中的十六进制浮点数字面值，而由 C 的 <code class="docutils literal notranslate"><span class="pre">%a</span></code> 格式字符或 Java 的 <code class="docutils literal notranslate"><span class="pre">Double.toHexString</span></code> 所生成的十六进制数字符串由为 <a class="reference internal" href="#float.fromhex" title="float.fromhex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">float.fromhex()</span></code></a> 所接受。</p>
<p>请注意 exponent 是十进制数而非十六进制数，它给出要与系数相乘的 2 的幂次。 例如，十六进制数字符串 <code class="docutils literal notranslate"><span class="pre">0x3.a7p10</span></code> 表示浮点数 <code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">+</span> <span class="pre">10./16</span> <span class="pre">+</span> <span class="pre">7./16**2)</span> <span class="pre">*</span> <span class="pre">2.0**10</span></code> 即 <code class="docutils literal notranslate"><span class="pre">3740.0</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;0x3.a7p10&#39;</span><span class="p">)</span>
<span class="go">3740.0</span>
</pre></div>
</div>
<p>对 <code class="docutils literal notranslate"><span class="pre">3740.0</span></code> 应用反向转换会得到另一个代表相同数值的十六进制数字符串:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">hex</span><span class="p">(</span><span class="mf">3740.0</span><span class="p">)</span>
<span class="go">&#39;0x1.d380000000000p+11&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="hashing-of-numeric-types">
<span id="numeric-hash"></span><h3>数字类型的哈希运算<a class="headerlink" href="#hashing-of-numeric-types" title="永久链接至标题">¶</a></h3>
<p>对于可能为不同类型的数字 <code class="docutils literal notranslate"><span class="pre">x</span></code> 和 <code class="docutils literal notranslate"><span class="pre">y</span></code>，要求 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 时必定 <code class="docutils literal notranslate"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code> (详情参见 <a class="reference internal" href="datamodel.html#object.__hash__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 方法的文档)。 为了便于在各种数字类型 (包括 <a class="reference internal" href="functions.html#int" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Decimal" tppabs="https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a> 和 <a class="reference internal" href="fractions.html#fractions.Fraction" tppabs="https://docs.python.org/zh-cn/3/library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a>) 上实现并保证效率，Python 对数字类型的哈希运算是基于为任意有理数定义统一的数学函数，因此该运算对 <a class="reference internal" href="functions.html#int" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 和 <a class="reference internal" href="fractions.html#fractions.Fraction" tppabs="https://docs.python.org/zh-cn/3/library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> 的全部实例，以及 <a class="reference internal" href="functions.html#float" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 和 <a class="reference internal" href="decimal.html#decimal.Decimal" tppabs="https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a> 的全部有限实例均可用。 从本质上说，此函数是通过以一个固定质数 <code class="docutils literal notranslate"><span class="pre">P</span></code> 进行 <code class="docutils literal notranslate"><span class="pre">P</span></code> 降模给出的。 <code class="docutils literal notranslate"><span class="pre">P</span></code> 的值在 Python 中可以 <a class="reference internal" href="sys.html#sys.hash_info" tppabs="https://docs.python.org/zh-cn/3/library/sys.html#sys.hash_info" title="sys.hash_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.hash_info</span></code></a> 的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">modulus</span></code> 属性的形式被访问。</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> 目前所用的质数设定，在 C long 为 32 位的机器上 <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">2**31</span> <span class="pre">-</span> <span class="pre">1</span></code> 而在 C long 为 64 位的机器上 <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">2**61</span> <span class="pre">-</span> <span class="pre">1</span></code>。</p>
</div>
<p>详细规则如下所述:</p>
<ul class="simple">
<li>如果 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> 是一个非负的有理数且 <code class="docutils literal notranslate"><span class="pre">n</span></code> 不可被 <code class="docutils literal notranslate"><span class="pre">P</span></code> 整除，则定义 <code class="docutils literal notranslate"><span class="pre">hash(x)</span></code> 为 <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">invmod(n,</span> <span class="pre">P)</span> <span class="pre">%</span> <span class="pre">P</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">invmod(n,</span> <span class="pre">P)</span></code> 是对 <code class="docutils literal notranslate"><span class="pre">n</span></code> 模 <code class="docutils literal notranslate"><span class="pre">P</span></code> 取反。</li>
<li>如果 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> 是一个非负的有理数且 <code class="docutils literal notranslate"><span class="pre">n</span></code> 可被 <code class="docutils literal notranslate"><span class="pre">P</span></code> 整除（但 <code class="docutils literal notranslate"><span class="pre">m</span></code> 不能）则 <code class="docutils literal notranslate"><span class="pre">n</span></code> 不能对 <code class="docutils literal notranslate"><span class="pre">P</span></code> 降模，以上规则不适用；在此情况下则定义 <code class="docutils literal notranslate"><span class="pre">hash(x)</span></code> 为常数值 <code class="docutils literal notranslate"><span class="pre">sys.hash_info.inf</span></code>。</li>
<li>如果 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> 是一个负的有理数则定义 <code class="docutils literal notranslate"><span class="pre">hash(x)</span></code> 为 <code class="docutils literal notranslate"><span class="pre">-hash(-x)</span></code>。 如果结果哈希值为 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 则将其替换为 <code class="docutils literal notranslate"><span class="pre">-2</span></code>。</li>
<li>特定值 <code class="docutils literal notranslate"><span class="pre">sys.hash_info.inf</span></code>, <code class="docutils literal notranslate"><span class="pre">-sys.hash_info.inf</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sys.hash_info.nan</span></code> 被用作正无穷、负无穷和空值（所分别对应的）哈希值。 （所有可哈希的空值都具有相同的哈希值。）</li>
<li>对于一个 <a class="reference internal" href="functions.html#complex" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> 值 <code class="docutils literal notranslate"><span class="pre">z</span></code>，会通过计算 <code class="docutils literal notranslate"><span class="pre">hash(z.real)</span> <span class="pre">+</span> <span class="pre">sys.hash_info.imag</span> <span class="pre">*</span> <span class="pre">hash(z.imag)</span></code> 将实部和虚部的哈希值结合起来，并进行降模 <code class="docutils literal notranslate"><span class="pre">2**sys.hash_info.width</span></code> 以使其处于 <code class="docutils literal notranslate"><span class="pre">range(-2**(sys.hash_info.width</span> <span class="pre">-</span> <span class="pre">1),</span> <span class="pre">2**(sys.hash_info.width</span> <span class="pre">-</span> <span class="pre">1))</span></code> 范围之内。 同样地，如果结果为 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 则将其替换为 <code class="docutils literal notranslate"><span class="pre">-2</span></code>。</li>
</ul>
<p>为了阐明上述规则，这里有一些等价于内置哈希算法的 Python 代码示例，可用于计算有理数、<a class="reference internal" href="functions.html#float" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 或 <a class="reference internal" href="functions.html#complex" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> 的哈希值:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">hash_fraction</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a rational number m / n.</span>

<span class="sd">    Assumes m and n are integers, with n positive.</span>
<span class="sd">    Equivalent to hash(fractions.Fraction(m, n)).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">modulus</span>
    <span class="c1"># Remove common factors of P.  (Unnecessary if m and n already coprime.)</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">//</span> <span class="n">P</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="n">P</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Fermat&#39;s Little Theorem: pow(n, P-1, P) is 1, so</span>
        <span class="c1"># pow(n, P-2, P) gives the inverse of n modulo P.</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">%</span> <span class="n">P</span><span class="p">)</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">P</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="o">%</span> <span class="n">P</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="n">hash_value</span>
    <span class="k">if</span> <span class="n">hash_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">hash_value</span>

<span class="k">def</span> <span class="nf">hash_float</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a float x.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">elif</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hash_fraction</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">hash_complex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a complex number z.&quot;&quot;&quot;</span>

    <span class="n">hash_value</span> <span class="o">=</span> <span class="n">hash_float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">hash_float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
    <span class="c1"># do a signed reduction modulo 2**sys.hash_info.width</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">hash_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&amp;</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hash_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">hash_value</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="iterator-types">
<span id="typeiter"></span><h2>迭代器类型<a class="headerlink" href="#iterator-types" title="永久链接至标题">¶</a></h2>
<p id="index-17">Python 支持在容器中进行迭代的概念。 这是通过使用两个单独方法来实现的；它们被用于允许用户自定义类对迭代的支持。 将在下文中详细描述的序列总是支持迭代方法。</p>
<p>容器对象要提供迭代支持，必须定义一个方法:</p>
<dl class="method">
<dt id="container.__iter__">
<code class="descclassname">container.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#container.__iter__" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个迭代器对象。 该对象需要支持下文所述的迭代器协议。 如果容器支持不同的迭代类型，则可以提供额外的方法来专门地请求不同迭代类型的迭代器。 （支持多种迭代形式的对象的例子有同时支持广度优先和深度优先遍历的树结构。） 此方法对应于 Python/C API 中 Python 对象类型结构体的 <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_iter" tppabs="https://docs.python.org/zh-cn/3/c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a> 槽位。</p>
</dd></dl>

<p>迭代器对象自身需要支持以下两个方法，它们共同组成了 <em class="dfn">迭代器协议</em>:</p>
<dl class="method">
<dt id="iterator.__iter__">
<code class="descclassname">iterator.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iterator.__iter__" title="永久链接至目标">¶</a></dt>
<dd><p>返回迭代器对象本身。 这是同时允许容器和迭代器配合 <a class="reference internal" href="compound_stmts.html#for" tppabs="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 和 <a class="reference internal" href="expressions.html#in" tppabs="https://docs.python.org/zh-cn/3/reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 语句使用所必须的。 此方法对应于 Python/C API 中 Python 对象类型结构体的 <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_iter" tppabs="https://docs.python.org/zh-cn/3/c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a> 槽位。</p>
</dd></dl>

<dl class="method">
<dt id="iterator.__next__">
<code class="descclassname">iterator.</code><code class="descname">__next__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iterator.__next__" title="永久链接至目标">¶</a></dt>
<dd><p>从容器中返回下一项。 如果已经没有项可返回，则会引发 <a class="reference internal" href="exceptions.html#StopIteration" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 异常。 此方法对应于 Python/C API 中 Python 对象类型结构体的 <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_iternext" tppabs="https://docs.python.org/zh-cn/3/c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iternext</span></code></a> 槽位。</p>
</dd></dl>

<p>Python 定义了几种迭代器对象以支持对一般和特定序列类型、字典和其他更特别的形式进行迭代。 除了迭代器协议的实现，特定类型的其他性质对迭代操作来说都不重要。</p>
<p>一旦迭代器的 <a class="reference internal" href="#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法引发了 <a class="reference internal" href="exceptions.html#StopIteration" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>，它必须一直对后续调用引发同样的异常。 不遵循此行为特性的实现将无法正常使用。</p>
<div class="section" id="generator-types">
<span id="id3"></span><h3>生成器类型<a class="headerlink" href="#generator-types" title="永久链接至标题">¶</a></h3>
<p>Python 的 <a class="reference internal" href="glossary.html#term-generator" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-generator"><span class="xref std std-term">generator</span></a> 提供了一种实现迭代器协议的便捷方式。 如果容器对象 <a class="reference internal" href="datamodel.html#object.__iter__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 方法被实现为一个生成器，它将自动返回一个迭代器对象（从技术上说是一个生成器对象），该对象提供 <a class="reference internal" href="datamodel.html#object.__iter__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 和 <a class="reference internal" href="expressions.html#generator.__next__" tppabs="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法。 有关生成器的更多信息可以参阅 <a class="reference internal" href="expressions.html#yieldexpr" tppabs="https://docs.python.org/zh-cn/3/reference/expressions.html#yieldexpr"><span class="std std-ref">yield 表达式的文档</span></a>。</p>
</div>
</div>
<div class="section" id="sequence-types-list-tuple-range">
<span id="typesseq"></span><h2>序列类型 --- <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a><a class="headerlink" href="#sequence-types-list-tuple-range" title="永久链接至标题">¶</a></h2>
<p>有三种基本序列类型：list, tuple 和 range 对象。 为处理 <a class="reference internal" href="#binaryseq"><span class="std std-ref">二进制数据</span></a> 和 <a class="reference internal" href="#textseq"><span class="std std-ref">文本字符串</span></a> 而特别定制的附加序列类型会在专门的小节中描述。</p>
<div class="section" id="common-sequence-operations">
<span id="typesseq-common"></span><h3>通用序列操作<a class="headerlink" href="#common-sequence-operations" title="永久链接至标题">¶</a></h3>
<p id="index-18">大多数序列类型，包括可变类型和不可变类型都支持下表中的操作。 <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" tppabs="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> ABC 被提供用来更容易地在自定义序列类型上正确地实现这些操作。</p>
<p>此表按优先级升序列出了序列操作。 在表格中，<em>s</em> 和 <em>t</em> 是具有相同类型的序列，<em>n</em>, <em>i</em>, <em>j</em> 和 <em>k</em> 是整数而 <em>x</em> 是任何满足 <em>s</em> 所规定的类型和值限制的任意对象。</p>
<p><code class="docutils literal notranslate"><span class="pre">in</span></code> 和 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code> 操作具有与比较操作相同的优先级。 <code class="docutils literal notranslate"><span class="pre">+</span></code> (拼接) 和 <code class="docutils literal notranslate"><span class="pre">*</span></code> (重复) 操作具有与对应数值运算相同的优先级。 <a class="footnote-reference" href="#id14" id="id4">[3]</a></p>
<table border="1" class="docutils" id="index-19">
<colgroup>
<col width="38%" />
<col width="47%" />
<col width="15%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">运算</th>
<th class="head">结果</th>
<th class="head">注释</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code></td>
<td>如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则为 <code class="docutils literal notranslate"><span class="pre">False</span></code></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code></td>
<td>如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，否则为 <code class="docutils literal notranslate"><span class="pre">True</span></code></td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">+</span> <span class="pre">t</span></code></td>
<td><em>s</em> 与 <em>t</em> 相拼接</td>
<td>(6)(7)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n</span></code> 或 <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">s</span></code></td>
<td>相当于 <em>s</em> 与自身进行 <em>n</em> 次拼接</td>
<td>(2)(7)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">s[i]</span></code></td>
<td><em>s</em> 的第 <em>i</em> 项，起始为 0</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">s[i:j]</span></code></td>
<td><em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片</td>
<td>(3)(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">s[i:j:k]</span></code></td>
<td><em>s</em> 从 <em>i</em> 到 <em>j</em> 步长为 <em>k</em> 的切片</td>
<td>(3)(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">len(s)</span></code></td>
<td><em>s</em> 的长度</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">min(s)</span></code></td>
<td><em>s</em> 的最小项</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">max(s)</span></code></td>
<td><em>s</em> 的最大项</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">s.index(x[,</span> <span class="pre">i[,</span> <span class="pre">j]])</span></code></td>
<td><em>x</em> 在 <em>s</em> 中首次出现项的索引号（索引号在 <em>i</em> 或其后且在 <em>j</em> 之前）</td>
<td>(8)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">s.count(x)</span></code></td>
<td><em>x</em> 在 <em>s</em> 中出现的总次数</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>相同类型的序列也支持比较。 特别地，tuple 和 list 的比较是通过比较对应元素的字典顺序。 这意味着想要比较结果相等，则每个元素比较结果都必须相等，并且两个序列长度必须相同。 （完整细节请参阅语言参考的 <a class="reference internal" href="expressions.html#comparisons" tppabs="https://docs.python.org/zh-cn/3/reference/expressions.html#comparisons"><span class="std std-ref">比较运算</span></a> 部分。）</p>
<p>注释:</p>
<ol class="arabic">
<li><p class="first">虽然 <code class="docutils literal notranslate"><span class="pre">in</span></code> 和 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code> 操作在通常情况下仅被用于简单的成员检测，某些专门化序列 (例如 <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 和 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) 也使用它们进行子序列检测:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;gg&quot;</span> <span class="ow">in</span> <span class="s2">&quot;eggs&quot;</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p class="first">小于 <code class="docutils literal notranslate"><span class="pre">0</span></code> 的 <em>n</em> 值会被当作 <code class="docutils literal notranslate"><span class="pre">0</span></code> 来处理 (生成一个与 <em>s</em> 同类型的空序列)。 请注意序列 <em>s</em> 中的项并不会被拷贝；它们会被多次引用。 这一点经常会令 Python 编程新手感到困扰；例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[], [], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [3], [3]]</span>
</pre></div>
</div>
<p>具体的原因在于 <code class="docutils literal notranslate"><span class="pre">[[]]</span></code> 是一个包含了一个空列表的单元素列表，所以 <code class="docutils literal notranslate"><span class="pre">[[]]</span> <span class="pre">*</span> <span class="pre">3</span></code> 结果中的三个元素都是对这一个空列表的引用。 修改 <code class="docutils literal notranslate"><span class="pre">lists</span></code> 中的任何一个元素实际上都是对这一个空列表的修改。 你可以用以下方式创建以不同列表为元素的列表:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [5], [7]]</span>
</pre></div>
</div>
<p>进一步的解释可以在 FAQ 条目 <a class="reference internal" href="programming.html#faq-multidimensional-list" tppabs="https://docs.python.org/zh-cn/3/faq/programming.html#faq-multidimensional-list"><span class="std std-ref">How do I create a multidimensional list?</span></a> 中查看。</p>
</li>
<li><p class="first">如果 <em>i</em> 或 <em>j</em> 为负值，则索引顺序是相对于序列 <em>s</em> 的末尾: 索引号会被替换为 <code class="docutils literal notranslate"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">i</span></code> 或 <code class="docutils literal notranslate"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">j</span></code>。 但要注意 <code class="docutils literal notranslate"><span class="pre">-0</span></code> 仍然为 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
</li>
<li><p class="first"><em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片被定义为所有满足 <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">j</span></code> 的索引号 <em>k</em> 的项组成的序列。 如果 <em>i</em> 或 <em>j</em> 大于 <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>，则使用 <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>。 如果 <em>i</em> 被省略或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则使用 <code class="docutils literal notranslate"><span class="pre">0</span></code>。 如果 <em>j</em> 被省略或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则使用 <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>。 如果 <em>i</em> 大于等于 <em>j</em>，则切片为空。</p>
</li>
<li><p class="first"><em>s</em> 从 <em>i</em> 到 <em>j</em> 步长为 <em>k</em> 的切片被定义为所有满足 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">(j-i)/k</span></code> 的索引号  <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code> 的项组成的序列。 换句话说，索引号为 <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">i+k</span></code>, <code class="docutils literal notranslate"><span class="pre">i+2*k</span></code>, <code class="docutils literal notranslate"><span class="pre">i+3*k</span></code>，以此类推，当达到 <em>j</em> 时停止 (但一定不包括 <em>j</em>)。 当 <em>k</em> 为正值时，<em>i</em> 和 <em>j</em> 会被减至不大于 <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>。 当 <em>k</em> 为负值时，<em>i</em> 和 <em>j</em> 会被减至不大于 <code class="docutils literal notranslate"><span class="pre">len(s)</span> <span class="pre">-</span> <span class="pre">1</span></code>。 如果 <em>i</em> 或 <em>j</em> 被省略或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，它们会成为“终止”值 (是哪一端的终止值则取决于 <em>k</em> 的符号)。 请注意，<em>k</em> 不可为零。 如果 <em>k</em> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则当作 <code class="docutils literal notranslate"><span class="pre">1</span></code> 处理。</p>
</li>
<li><p class="first">拼接不可变序列总是会生成新的对象。 这意味着通过重复拼接来构建序列的运行时开销将会基于序列总长度的乘方。 想要获得线性的运行时开销，你必须改用下列替代方案之一：</p>
<ul class="simple">
<li>如果拼接 <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 对象，你可以构建一个列表并在最后使用 <a class="reference internal" href="#str.join" title="str.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.join()</span></code></a> 或是写入一个 <a class="reference internal" href="io.html#io.StringIO" tppabs="https://docs.python.org/zh-cn/3/library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> 实例并在结束时获取它的值</li>
<li>如果拼接 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象，你可以类似地使用 <a class="reference internal" href="#bytes.join" title="bytes.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.join()</span></code></a> 或 <a class="reference internal" href="io.html#io.BytesIO" tppabs="https://docs.python.org/zh-cn/3/library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a>，或者你也可以使用 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 对象进行原地拼接。 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 对象是可变的，并且具有高效的重分配机制</li>
<li>如果拼接 <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 对象，请改为扩展 <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 类</li>
<li>对于其它类型，请查看相应的文档</li>
</ul>
</li>
<li><p class="first">某些序列类型 (例如 <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a>) 仅支持遵循特定模式的项序列，因此并不支持序列拼接或重复。</p>
</li>
<li><p class="first">当 <em>x</em> 在 <em>s</em> 中找不到时 <code class="docutils literal notranslate"><span class="pre">index</span></code> 会引发 <a class="reference internal" href="exceptions.html#ValueError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。 不是所有实现都支持传入额外参数 <em>i</em> 和 <em>j</em>。 这两个参数允许高效地搜索序列的子序列。 传入这两个额外参数大致相当于使用 <code class="docutils literal notranslate"><span class="pre">s[i:j].index(x)</span></code>，但是不会复制任何数据，并且返回的索引是相对于序列的开头而非切片的开头。</p>
</li>
</ol>
</div>
<div class="section" id="immutable-sequence-types">
<span id="typesseq-immutable"></span><h3>不可变序列类型<a class="headerlink" href="#immutable-sequence-types" title="永久链接至标题">¶</a></h3>
<p id="index-20">不可变序列类型普遍实现而可变序列类型未实现的唯一操作就是对 <a class="reference internal" href="functions.html#hash" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 内置函数的支持。</p>
<p>这种支持允许不可变类型，例如 <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 实例被用作 <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 键，以及存储在 <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 和 <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 实例中。</p>
<p>尝试对包含有不可哈希值的不可变序列进行哈希运算将会导致 <a class="reference internal" href="exceptions.html#TypeError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
</div>
<div class="section" id="mutable-sequence-types">
<span id="typesseq-mutable"></span><h3>可变序列类型<a class="headerlink" href="#mutable-sequence-types" title="永久链接至标题">¶</a></h3>
<p id="index-21">以下表格中的操作是在可变序列类型上定义的。 <a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" tppabs="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a> ABC 被提供用来更容易地在自定义序列类型上正确实现这些操作。</p>
<p>表格中的 <em>s</em> 是可变序列类型的实例，<em>t</em> 是任意可迭代对象，而 <em>x</em> 是符合对 <em>s</em> 所规定类型与值限制的任何对象 (例如，<a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 仅接受满足 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">255</span></code> 值限制的整数)。</p>
<table border="1" class="docutils" id="index-22">
<colgroup>
<col width="36%" />
<col width="39%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">运算</th>
<th class="head">结果</th>
<th class="head">注释</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">s[i]</span> <span class="pre">=</span> <span class="pre">x</span></code></td>
<td>将 <em>s</em> 的第 <em>i</em> 项替换为 <em>x</em></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">t</span></code></td>
<td>将 <em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片替换为可迭代对象 <em>t</em> 的内容</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">s[i:j]</span></code></td>
<td>等同于 <code class="docutils literal notranslate"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">[]</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">s[i:j:k]</span> <span class="pre">=</span> <span class="pre">t</span></code></td>
<td>将 <code class="docutils literal notranslate"><span class="pre">s[i:j:k]</span></code> 的元素替换为 <em>t</em> 的元素</td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">s[i:j:k]</span></code></td>
<td>从列表中移除 <code class="docutils literal notranslate"><span class="pre">s[i:j:k]</span></code> 的元素</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">s.append(x)</span></code></td>
<td>将 <em>x</em> 添加到序列的末尾 (等同于 <code class="docutils literal notranslate"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">[x]</span></code>)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">s.clear()</span></code></td>
<td>从 <em>s</em> 中移除所有项 (等同于 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">s[:]</span></code>)</td>
<td>(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">s.copy()</span></code></td>
<td>创建 <em>s</em> 的浅拷贝 (等同于 <code class="docutils literal notranslate"><span class="pre">s[:]</span></code>)</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">s.extend(t)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">+=</span> <span class="pre">t</span></code></td>
<td>用 <em>t</em> 的内容扩展 <em>s</em> (基本上等同于 <code class="docutils literal notranslate"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">t</span></code>)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">*=</span> <span class="pre">n</span></code></td>
<td>使用 <em>s</em> 的内容重复 <em>n</em> 次来对其进行更新</td>
<td>(6)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">s.insert(i,</span> <span class="pre">x)</span></code></td>
<td>在由 <em>i</em> 给出的索引位置将 <em>x</em> 插入 <em>s</em> (等同于 <code class="docutils literal notranslate"><span class="pre">s[i:i]</span> <span class="pre">=</span> <span class="pre">[x]</span></code>)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">s.pop([i])</span></code></td>
<td>提取在 <em>i</em> 位置上的项，并将其从 <em>s</em> 中移除</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">s.remove(x)</span></code></td>
<td>删除 <em>s</em> 中第一个 <code class="docutils literal notranslate"><span class="pre">s[i]</span></code>&nbsp;等于 <em>x</em> 的项目。</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">s.reverse()</span></code></td>
<td>就地将列表中的元素逆序。</td>
<td>(4)</td>
</tr>
</tbody>
</table>
<p>注释:</p>
<ol class="arabic">
<li><p class="first"><em>t</em> 必须与它所替换的切片具有相同的长度。</p>
</li>
<li><p class="first">可选参数 <em>i</em> 默认为 <code class="docutils literal notranslate"><span class="pre">-1</span></code>，因此在默认情况下会移除并返回最后一项。</p>
</li>
<li><p class="first">当在 <em>s</em> 中找不到 <em>x</em> 时 <code class="docutils literal notranslate"><span class="pre">remove</span></code> 操作会引发 <a class="reference internal" href="exceptions.html#ValueError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
</li>
<li><p class="first">当反转大尺寸序列时 <code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code> 方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回反转后的序列。</p>
</li>
<li><p class="first">包括 <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code> 是为了与不支持切片操作的可变容器 (例如 <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 和 <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>) 的接口保持一致</p>
<div class="versionadded">
<p><span class="versionmodified">3.3 新版功能: </span><code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code> 方法。</p>
</div>
</li>
<li><p class="first"><em>n</em> 值为一个整数，或是一个实现了 <a class="reference internal" href="datamodel.html#object.__index__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 的对象。 <em>n</em> 值为零或负数将清空序列。 序列中的项不会被拷贝；它们会被多次引用，正如 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">通用序列操作</span></a> 中有关 <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n</span></code> 的说明。</p>
</li>
</ol>
</div>
<div class="section" id="lists">
<span id="typesseq-list"></span><h3>列表<a class="headerlink" href="#lists" title="永久链接至标题">¶</a></h3>
<p id="index-23">列表是可变序列，通常用于存放同类项目的集合（其中精确的相似程度将根据应用而变化）。</p>
<dl class="class">
<dt id="list">
<em class="property">class </em><code class="descname">list</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#list" title="永久链接至目标">¶</a></dt>
<dd><p>可以用多种方式构建列表：</p>
<ul class="simple">
<li>使用一对方括号来表示空列表: <code class="docutils literal notranslate"><span class="pre">[]</span></code></li>
<li>使用方括号，其中的项以逗号分隔: <code class="docutils literal notranslate"><span class="pre">[a]</span></code>, <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c]</span></code></li>
<li>使用列表推导式: <code class="docutils literal notranslate"><span class="pre">[x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">iterable]</span></code></li>
<li>使用类型的构造器: <code class="docutils literal notranslate"><span class="pre">list()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">list(iterable)</span></code></li>
</ul>
<p>构造器将构造一个列表，其中的项与 <em>iterable</em> 中的项具有相同的的值与顺序。 <em>iterable</em> 可以是序列、支持迭代的容器或其它可迭代对象。 如果 <em>iterable</em> 已经是一个列表，将创建并返回其副本，类似于 <code class="docutils literal notranslate"><span class="pre">iterable[:]</span></code>。 例如，<code class="docutils literal notranslate"><span class="pre">list('abc')</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code> 而 <code class="docutils literal notranslate"><span class="pre">list(</span> <span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span> <span class="pre">)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>。 如果没有给出参数，构造器将创建一个空列表 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。</p>
<p>其它许多操作也会产生列表，包括 <a class="reference internal" href="functions.html#sorted" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> 内置函数。</p>
<p>列表实现了所有 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">一般</span></a> 和 <a class="reference internal" href="#typesseq-mutable"><span class="std std-ref">可变</span></a> 序列的操作。 列表还额外提供了以下方法：</p>
<dl class="method">
<dt id="list.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>*</em>, <em>key=None</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#list.sort" title="永久链接至目标">¶</a></dt>
<dd><p>此方法会对列表进行原地排序，只使用 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> 来进行各项间比较。 异常不会被屏蔽 —— 如果有任何比较操作失败，整个排序操作将失败（而列表可能会处于被部分修改的状态）。</p>
<p><a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code></a> 接受两个仅限以关键字形式传入的参数 (<a class="reference internal" href="glossary.html#keyword-only-parameter" tppabs="https://docs.python.org/zh-cn/3/glossary.html#keyword-only-parameter"><span class="std std-ref">仅限关键字参数</span></a>):</p>
<p><em>key</em> 指定带有一个参数的函数，用于从每个列表元素中提取比较键 (例如 <code class="docutils literal notranslate"><span class="pre">key=str.lower</span></code>)。 对应于列表中每一项的键会被计算一次，然后在整个排序过程中使用。 默认值 <code class="docutils literal notranslate"><span class="pre">None</span></code> 表示直接对列表项排序而不计算一个单独的键值。</p>
<p>可以使用 <a class="reference internal" href="functools.html#functools.cmp_to_key" tppabs="https://docs.python.org/zh-cn/3/library/functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.cmp_to_key()</span></code></a> 将 2.x 风格的 <em>cmp</em> 函数转换为 <em>key</em> 函数。</p>
<p><em>reverse</em> 为一个布尔值。 如果设为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则每个列表元素将按反向顺序比较进行排序。</p>
<p>当顺序大尺寸序列时此方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回排序后的序列（请使用 <a class="reference internal" href="functions.html#sorted" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> 显示地请求一个新的已排序列表实例）。</p>
<p><a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code></a> 方法确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 --- 这有利于进行多重排序（例如先按部门、再接薪级排序）。</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> 在一个列表被排序期间，尝试改变甚至进行检测也会造成未定义的影响。 Python 的 C 实现会在排序期间将列表显示为空，如果发现列表在排序期间被改变将会引发 <a class="reference internal" href="exceptions.html#ValueError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tuples">
<span id="typesseq-tuple"></span><h3>元组<a class="headerlink" href="#tuples" title="永久链接至标题">¶</a></h3>
<p id="index-24">元组是不可变序列，通常用于储存异构数据的多项集（例如由 <a class="reference internal" href="functions.html#enumerate" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> 内置函数所产生的二元组）。 元组也被用于需要同构数据的不可变序列的情况（例如允许存储到 <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 或 <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 的实例）。</p>
<dl class="class">
<dt id="tuple">
<em class="property">class </em><code class="descname">tuple</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#tuple" title="永久链接至目标">¶</a></dt>
<dd><p>可以用多种方式构建元组：</p>
<ul class="simple">
<li>使用一对圆括号来表示空元组: <code class="docutils literal notranslate"><span class="pre">()</span></code></li>
<li>使用一个后缀的逗号来表示单元组: <code class="docutils literal notranslate"><span class="pre">a,</span></code> 或 <code class="docutils literal notranslate"><span class="pre">(a,)</span></code></li>
<li>使用以逗号分隔的多个项: <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c</span></code> or <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code></li>
<li>使用内置的 <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">tuple()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">tuple()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">tuple(iterable)</span></code></li>
</ul>
<p>构造器将构造一个元组，其中的项与 <em>iterable</em> 中的项具有相同的值与顺序。 <em>iterable</em> 可以是序列、支持迭代的容器或其他可迭代对象。 如果 <em>iterable</em> 已经是一个元组，会不加改变地将其返回。 例如，<code class="docutils literal notranslate"><span class="pre">tuple('abc')</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'c')</span></code> 而 <code class="docutils literal notranslate"><span class="pre">tuple(</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span> <span class="pre">)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code>。 如果没有给出参数，构造器将创建一个空元组 <code class="docutils literal notranslate"><span class="pre">()</span></code>。</p>
<p>请注意决定生成元组的其实是逗号而不是圆括号。 圆括号只是可选的，生成空元组或需要避免语法歧义的情况除外。 例如，<code class="docutils literal notranslate"><span class="pre">f(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> 是在调用函数时附带三个参数，而 <code class="docutils literal notranslate"><span class="pre">f((a,</span> <span class="pre">b,</span> <span class="pre">c))</span></code> 则是在调用函数时附带一个三元组。</p>
<p>元组实现了所有 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">一般</span></a> 序列的操作。</p>
</dd></dl>

<p>对于通过名称访问相比通过索引访问更清晰的异构数据多项集，<a class="reference internal" href="collections.html#collections.namedtuple" tppabs="https://docs.python.org/zh-cn/3/library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a> 可能是比简单元组对象更为合适的选择。</p>
</div>
<div class="section" id="ranges">
<span id="typesseq-range"></span><h3>range 对象<a class="headerlink" href="#ranges" title="永久链接至标题">¶</a></h3>
<p id="index-25"><a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> 类型表示不可变的数字序列，通常用于在 <a class="reference internal" href="compound_stmts.html#for" tppabs="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 循环中循环指定的次数。</p>
<dl class="class">
<dt id="range">
<em class="property">class </em><code class="descname">range</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span><a class="headerlink" href="#range" title="永久链接至目标">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">range</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>range 构造器的参数必须为整数（可以是内置的 <a class="reference internal" href="functions.html#int" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 或任何实现了 <code class="docutils literal notranslate"><span class="pre">__index__</span></code> 特殊方法的对象）。 如果省略 <em>step</em> 参数，其默认值为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。 如果省略 <em>start</em> 参数，其默认值为 <code class="docutils literal notranslate"><span class="pre">0</span></code>，如果 <em>step</em> 为零则会引发 <a class="reference internal" href="exceptions.html#ValueError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>如果 <em>step</em> 为正值，确定 range <code class="docutils literal notranslate"><span class="pre">r</span></code> 内容的公式为 <code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">step*i</span></code> 其中 <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> 且 <code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">&lt;</span> <span class="pre">stop</span></code>。</p>
<p>如果 <em>step</em> 为负值，确定 range 内容的公式仍然为 <code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">step*i</span></code>，但限制条件改为 <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> 且 <code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">&gt;</span> <span class="pre">stop</span></code>.</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">r[0]</span></code> 不符合值的限制条件，则该 range 对象为空。 range 对象确实支持负索引，但是会将其解读为从正索引所确定的序列的末尾开始索引。</p>
<p>元素绝对值大于 <a class="reference internal" href="sys.html#sys.maxsize" tppabs="https://docs.python.org/zh-cn/3/library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a> 的 range 对象是被允许的，但某些特性 (例如 <a class="reference internal" href="functions.html#len" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>) 可能引发 <a class="reference internal" href="exceptions.html#OverflowError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。</p>
<p>一些 range 对象的例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">[0, 5, 10, 15, 20, 25]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[0, 3, 6, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>range 对象实现了 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">一般</span></a> 序列的所有操作，但拼接和重复除外（这是由于 range 对象只能表示符合严格模式的序列，而重复和拼接通常都会违反这样的模式）。</p>
<dl class="attribute">
<dt id="range.start">
<code class="descname">start</code><a class="headerlink" href="#range.start" title="永久链接至目标">¶</a></dt>
<dd><p><em>start</em> 形参的值 (如果该形参未提供则为 <code class="docutils literal notranslate"><span class="pre">0</span></code>)</p>
</dd></dl>

<dl class="attribute">
<dt id="range.stop">
<code class="descname">stop</code><a class="headerlink" href="#range.stop" title="永久链接至目标">¶</a></dt>
<dd><p><em>stop</em> 形参的值</p>
</dd></dl>

<dl class="attribute">
<dt id="range.step">
<code class="descname">step</code><a class="headerlink" href="#range.step" title="永久链接至目标">¶</a></dt>
<dd><p><em>step</em> 形参的值 (如果该形参未提供则为 <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> 类型相比常规 <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 或 <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 的优势在于一个 <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> 对象总是占用固定数量的（较小）内存，不论其所表示的范围有多大（因为它只保存了 <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">stop</span></code> 和 <code class="docutils literal notranslate"><span class="pre">step</span></code> 值，并会根据需要计算具体单项或子范围的值）。</p>
<p>range 对象实现了 <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" tppabs="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> ABC，提供如包含检测、元素索引查找、切片等特性，并支持负索引 (参见 <a class="reference internal" href="#typesseq"><span class="std std-ref">序列类型 --- list, tuple, range</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span>
<span class="go">range(0, 20, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">11</span> <span class="ow">in</span> <span class="n">r</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">10</span> <span class="ow">in</span> <span class="n">r</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">range(0, 10, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">18</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">==</span></code> 和 <code class="docutils literal notranslate"><span class="pre">!=</span></code> 检测 range 对象是否相等是将其作为序列来比较。 也就是说，如果两个 range 对象表示相同的值序列就认为它们是相等的。 （请注意比较结果相等的两个 range 对象可能会具有不同的 <a class="reference internal" href="#range.start" title="range.start"><code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code></a>, <a class="reference internal" href="#range.stop" title="range.stop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code></a> 和 <a class="reference internal" href="#range.step" title="range.step"><code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code></a> 属性，例如 <code class="docutils literal notranslate"><span class="pre">range(0)</span> <span class="pre">==</span> <span class="pre">range(2,</span> <span class="pre">1,</span> <span class="pre">3)</span></code> 而 <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">3,</span> <span class="pre">2)</span> <span class="pre">==</span> <span class="pre">range(0,</span> <span class="pre">4,</span> <span class="pre">2)</span></code>。）</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.2 版更改: </span>实现 Sequence ABC。 支持切片和负数索引。 使用 <a class="reference internal" href="functions.html#int" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 对象在固定时间内进行成员检测，而不是逐一迭代所有项。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>定义 '==' 和 '!=' 以根据 range 对象所定义的值序列来进行比较（而不是根据对象的标识）。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.3 新版功能: </span><a class="reference internal" href="#range.start" title="range.start"><code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code></a>, <a class="reference internal" href="#range.stop" title="range.stop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code></a> 和 <a class="reference internal" href="#range.step" title="range.step"><code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code></a> 属性。</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<ul class="last simple">
<li><a class="reference external" href="javascript:if(confirm('http://code.activestate.com/recipes/579000/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://code.activestate.com/recipes/579000/'" tppabs="http://code.activestate.com/recipes/579000/">linspace recipe</a> 演示了如何实现一个延迟求值版本的适合浮点数应用的 range 对象。</li>
</ul>
</div>
</div>
</div>
<div class="section" id="text-sequence-type-str">
<span id="textseq"></span><span id="index-26"></span><h2>文本序列类型 --- <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a><a class="headerlink" href="#text-sequence-type-str" title="永久链接至标题">¶</a></h2>
<p>在 Python 中处理文本数据是使用 <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 对象，也称为 <em class="dfn">字符串</em>。 字符串是由 Unicode 码位构成的不可变 <a class="reference internal" href="#typesseq"><span class="std std-ref">序列</span></a>。 字符串字面值有多种不同的写法：</p>
<ul class="simple">
<li>单引号: <code class="docutils literal notranslate"><span class="pre">'允许包含有</span> <span class="pre">&quot;双&quot;</span> <span class="pre">引号'</span></code></li>
<li>双引号: <code class="docutils literal notranslate"><span class="pre">&quot;允许包含有</span> <span class="pre">'单'</span> <span class="pre">引号&quot;</span></code>。</li>
<li>三重引号: <code class="docutils literal notranslate"><span class="pre">'''三重单引号'''</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;三重双引号&quot;&quot;&quot;</span></code></li>
</ul>
<p>使用三重引号的字符串可以跨越多行 —— 其中所有的空白字符都将包含在该字符串字面值中。</p>
<p>作为单一表达式组成部分，之间只由空格分隔的多个字符串字面值会被隐式地转换为单个字符串字面值。 也就是说，<code class="docutils literal notranslate"><span class="pre">(&quot;spam</span> <span class="pre">&quot;</span> <span class="pre">&quot;eggs&quot;)</span> <span class="pre">==</span> <span class="pre">&quot;spam</span> <span class="pre">eggs&quot;</span></code>。</p>
<p>请参阅 <a class="reference internal" href="lexical_analysis.html#strings" tppabs="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#strings"><span class="std std-ref">字符串和字节串字面值</span></a> 有解有关不同字符串字面值的更多信息，包括所支持的转义序列，以及使用 <code class="docutils literal notranslate"><span class="pre">r</span></code> (&quot;raw&quot;) 前缀来禁用大多数转义序列的处理。</p>
<p>字符串也可以通过使用 <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 构造器从其他对象创建。</p>
<p>由于不存在单独的“字符”类型，对字符串做索引操作将产生一个长度为 1 的字符串。 也就是说，对于一个非空字符串 <em>s</em>, <code class="docutils literal notranslate"><span class="pre">s[0]</span> <span class="pre">==</span> <span class="pre">s[0:1]</span></code>。</p>
<p id="index-27">不存在可变的字符串类型，但是 <a class="reference internal" href="#str.join" title="str.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.join()</span></code></a> 或 <a class="reference internal" href="io.html#io.StringIO" tppabs="https://docs.python.org/zh-cn/3/library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> 可以被被用来根据多个片段高效率地构建字符串。</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>为了与 Python 2 系列的向下兼容，再次允许字符串字面值使用 <code class="docutils literal notranslate"><span class="pre">u</span></code> 前缀。 它对字符串字面值的含义没有影响，并且不能与 <code class="docutils literal notranslate"><span class="pre">r</span></code> 前缀同时出现。</p>
</div>
<span class="target" id="index-28"></span><dl class="class">
<dt id="str">
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=''</em><span class="sig-paren">)</span><a class="headerlink" href="#str" title="永久链接至目标">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=b''</em>, <em>encoding='utf-8'</em>, <em>errors='strict'</em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>object</em> 的 <a class="reference internal" href="#textseq"><span class="std std-ref">字符串</span></a> 版本。 如果未提供 <em>object</em> 则返回空字符串。 在其他情况下 <code class="docutils literal notranslate"><span class="pre">str()</span></code> 的行为取决于 <em>encoding</em> 或 <em>errors</em> 是否有给出，具体见下。</p>
<p>如果 <em>encoding</em> 或 <em>errors</em> 均未给出，<code class="docutils literal notranslate"><span class="pre">str(object)</span></code> 返回 <a class="reference internal" href="datamodel.html#object.__str__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__str__()</span></code></a>，这是 <em>object</em> 的“非正式”或格式良好的字符串表示。 对于字符串对象，这是该字符串本身。 如果 <em>object</em> 没有 <a class="reference internal" href="datamodel.html#object.__str__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> 方法，则 <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 将回退为返回 <a class="reference internal" href="functions.html#repr" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#repr" title="repr"><code class="xref py py-meth docutils literal notranslate"><span class="pre">repr(object)</span></code></a>。</p>
<p id="index-29">如果 <em>encoding</em> 或 <em>errors</em> 至少给出其中之一，则 <em>object</em> 应该是一个 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> (例如 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 或 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>)。 在此情况下，如果 <em>object</em> 是一个 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> (或 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) 对象，则 <code class="docutils literal notranslate"><span class="pre">str(bytes,</span> <span class="pre">encoding,</span> <span class="pre">errors)</span></code> 等价于 <a class="reference internal" href="#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode(encoding,</span> <span class="pre">errors)</span></code></a>。 否则的话，会在调用 <a class="reference internal" href="#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> 之前获取缓冲区对象下层的 bytes 对象。 请参阅 <a class="reference internal" href="#binaryseq"><span class="std std-ref">二进制序列类型 --- bytes, bytearray, memoryview</span></a> 与 <a class="reference internal" href="buffer.html#bufferobjects" tppabs="https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects"><span class="std std-ref">缓冲协议</span></a> 了解有关缓冲区对象的信息。</p>
<p>将一个 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象传入 <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 而不给出 <em>encoding</em> 或 <em>errors</em> 参数的操作属于第一种情况， 将返回非正式的字符串表示（另请参阅 Python 的 <a class="reference internal" href="cmdline.html#cmdoption-b" tppabs="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-b"><code class="xref std std-option docutils literal notranslate"><span class="pre">-b</span></code></a> 命令行选项）。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Zoot!&#39;</span><span class="p">)</span>
<span class="go">&quot;b&#39;Zoot!&#39;&quot;</span>
</pre></div>
</div>
<p>有关 <code class="docutils literal notranslate"><span class="pre">str</span></code> 类及其方法的更多信息，请参阅下面的 <a class="reference internal" href="#textseq"><span class="std std-ref">文本序列类型 --- str</span></a> 和 <a class="reference internal" href="#string-methods"><span class="std std-ref">字符串的方法</span></a> 小节。 要输出格式化字符串，请参阅 <a class="reference internal" href="lexical_analysis.html#f-strings" tppabs="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings"><span class="std std-ref">格式化字符串字面值</span></a> 和 <a class="reference internal" href="string.html#formatstrings" tppabs="https://docs.python.org/zh-cn/3/library/string.html#formatstrings"><span class="std std-ref">Format String Syntax</span></a> 小节。 此外还可以参阅 <a class="reference internal" href="text.html#stringservices" tppabs="https://docs.python.org/zh-cn/3/library/text.html#stringservices"><span class="std std-ref">文本处理服务</span></a> 小节。</p>
</dd></dl>

<div class="section" id="string-methods">
<span id="index-30"></span><span id="id5"></span><h3>字符串的方法<a class="headerlink" href="#string-methods" title="永久链接至标题">¶</a></h3>
<p id="index-31">字符串实现了所有 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">一般</span></a> 序列的操作，还额外提供了以下列出的一些附加方法。</p>
<p>字符串还支持两种字符串格式化样式，一种提供了很大程度的灵活性和可定制性 (参阅 <a class="reference internal" href="#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a>, <a class="reference internal" href="string.html#formatstrings" tppabs="https://docs.python.org/zh-cn/3/library/string.html#formatstrings"><span class="std std-ref">Format String Syntax</span></a> 和 <a class="reference internal" href="string.html#string-formatting" tppabs="https://docs.python.org/zh-cn/3/library/string.html#string-formatting"><span class="std std-ref">Custom String Formatting</span></a>) 而另一种是基于 C <code class="docutils literal notranslate"><span class="pre">printf</span></code> 样式的格式化，它可处理的类型范围较窄，并且更难以正确使用，但对于它可处理的情况往往会更为快速 (<a class="reference internal" href="#old-string-formatting"><span class="std std-ref">printf 风格的字符串格式化</span></a>)。</p>
<p>标准库的 <a class="reference internal" href="text.html#textservices" tppabs="https://docs.python.org/zh-cn/3/library/text.html#textservices"><span class="std std-ref">文本处理服务</span></a> 部分涵盖了许多其他模块，提供各种文本相关工具（例如包含于 <a class="reference internal" href="re.html#module-re" tppabs="https://docs.python.org/zh-cn/3/library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块中的正则表达式支持）。</p>
<dl class="method">
<dt id="str.capitalize">
<code class="descclassname">str.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.capitalize" title="永久链接至目标">¶</a></dt>
<dd><p>返回原字符串的副本，其首个字符大写，其余为小写。</p>
</dd></dl>

<dl class="method">
<dt id="str.casefold">
<code class="descclassname">str.</code><code class="descname">casefold</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.casefold" title="永久链接至目标">¶</a></dt>
<dd><p>返回原字符串消除大小写的副本。 消除大小写的字符串可用于忽略大小写的匹配。</p>
<p>消除大小写类似于转为小写，但是更加彻底一些，因为它会移除字符串中的所有大小写变化形式。 例如，德语小写字母 <code class="docutils literal notranslate"><span class="pre">'ß'</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">&quot;ss&quot;</span></code>。 由于它已经是小写了，<a class="reference internal" href="#str.lower" title="str.lower"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lower()</span></code></a> 不会对 <code class="docutils literal notranslate"><span class="pre">'ß'</span></code> 做任何改变；而 <a class="reference internal" href="#str.casefold" title="str.casefold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">casefold()</span></code></a> 则会将其转换为 <code class="docutils literal notranslate"><span class="pre">&quot;ss&quot;</span></code>。</p>
<p>消除大小写算法的描述请参见 Unicode 标准的 3.13 节。</p>
<div class="versionadded">
<p><span class="versionmodified">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.center">
<code class="descclassname">str.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.center" title="永久链接至目标">¶</a></dt>
<dd><p>返回长度为 <em>width</em> 的字符串，原字符串在其正中。 使用指定的 <em>fillchar</em> 填充两边的空位（默认使用 ASCII 空格符）。 如果 <em>width</em> 小于等于 <code class="docutils literal notranslate"><span class="pre">len(s)</span></code> 则返回原字符串的副本。</p>
</dd></dl>

<dl class="method">
<dt id="str.count">
<code class="descclassname">str.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.count" title="永久链接至目标">¶</a></dt>
<dd><p>反回子字符串 <em>sub</em> 在 [<em>start</em>, <em>end</em>] 范围内非重叠出现的次数。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。</p>
</dd></dl>

<dl class="method">
<dt id="str.encode">
<code class="descclassname">str.</code><code class="descname">encode</code><span class="sig-paren">(</span><em>encoding=&quot;utf-8&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#str.encode" title="永久链接至目标">¶</a></dt>
<dd><p>返回原字符串编码为字节串对象的版本。 默认编码为 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>。 可以给出 <em>errors</em> 来设置不同的错误处理方案。 <em>errors</em> 的默认值为 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>，表示编码错误会引发 <a class="reference internal" href="exceptions.html#UnicodeError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>。 其他可用的值为 <code class="docutils literal notranslate"><span class="pre">'ignore'</span></code>, <code class="docutils literal notranslate"><span class="pre">'replace'</span></code>, <code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code>, <code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> 以及任何其他通过 <a class="reference internal" href="codecs.html#codecs.register_error" tppabs="https://docs.python.org/zh-cn/3/library/codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.register_error()</span></code></a> 注册的值，请参阅 <a class="reference internal" href="codecs.html#error-handlers" tppabs="https://docs.python.org/zh-cn/3/library/codecs.html#error-handlers"><span class="std std-ref">Error Handlers</span></a> 小节。 要查看可用的编码列表，请参阅 <a class="reference internal" href="codecs.html#standard-encodings" tppabs="https://docs.python.org/zh-cn/3/library/codecs.html#standard-encodings"><span class="std std-ref">标准编码</span></a> 小节。</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.1 版更改: </span>加入了对关键字参数的支持。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.endswith">
<code class="descclassname">str.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.endswith" title="永久链接至目标">¶</a></dt>
<dd><p>如果字符串以指定的 <em>suffix</em> 结束返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 <em>suffix</em> 也可以为由多个供查找的后缀构成的元组。 如果有可选项 <em>start</em>，将从所指定位置开始检查。 如果有可选项 <em>end</em>，将在所指定位置停止比较。</p>
</dd></dl>

<dl class="method">
<dt id="str.expandtabs">
<code class="descclassname">str.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span><a class="headerlink" href="#str.expandtabs" title="永久链接至目标">¶</a></dt>
<dd><p>返回字符串的副本，其中所有的制表符会由一个或多个空格替换，具体取决于当前列宽度和给定的制表符宽度。 每 <em>tabsize</em> 个字符设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依次类推）。 要展开字符串，当前列将被设为零并逐一检查字符串中的每个字符。 如果字符为制表符 (<code class="docutils literal notranslate"><span class="pre">\t</span></code>)，则会在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本身不会被复制。） 如果字符为换行符 (<code class="docutils literal notranslate"><span class="pre">\n</span></code>) 或回车符 (<code class="docutils literal notranslate"><span class="pre">\r</span></code>)，它会被复制并将当前列重设为零。 任何其他字符会被不加修改地复制并将当前列加一，不论该字符在被打印时会如何显示。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
<span class="go">&#39;01      012     0123    01234&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;01  012 0123    01234&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.find">
<code class="descclassname">str.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.find" title="永久链接至目标">¶</a></dt>
<dd><p>返回子字符串 <em>sub</em> 在 <code class="docutils literal notranslate"><span class="pre">s[start:end]</span></code> 切片内被找到的最小索引。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果 <em>sub</em> 未被找到则返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p><a class="reference internal" href="#str.find" title="str.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> 方法应该只在你需要知道 <em>sub</em> 所在位置时使用。 要检查 <em>sub</em> 是否为子字符串，请使用 <a class="reference internal" href="expressions.html#in" tppabs="https://docs.python.org/zh-cn/3/reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 操作符:</p>
<div class="last highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Py&#39;</span> <span class="ow">in</span> <span class="s1">&#39;Python&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.format">
<code class="descclassname">str.</code><code class="descname">format</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#str.format" title="永久链接至目标">¶</a></dt>
<dd><p>执行字符串格式化操作。 调用此方法的字符串可以包含字符串字面值或者以花括号 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 括起来的替换域。 每个替换域可以包含一个位置参数的数字索引，或者一个关键字参数的名称。 返回的字符串副本中每个替换域都会被替换为对应参数的字符串值。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;The sum of 1 + 2 is </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;The sum of 1 + 2 is 3&#39;</span>
</pre></div>
</div>
<p>请参阅 <a class="reference internal" href="string.html#formatstrings" tppabs="https://docs.python.org/zh-cn/3/library/string.html#formatstrings"><span class="std std-ref">Format String Syntax</span></a> 了解有关可以在格式字符串中指定的各种格式选项的说明。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">当使用 <code class="docutils literal notranslate"><span class="pre">n</span></code> 类型 (例如: <code class="docutils literal notranslate"><span class="pre">'{:n}'.format(1234)</span></code>) 来格式化数字 (<a class="reference internal" href="functions.html#int" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#complex" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Decimal" tppabs="https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a> 及其子类) 的时候，该函数会临时性地将 <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> 区域设置为 <code class="docutils literal notranslate"><span class="pre">LC_NUMERIC</span></code> 区域以解码  <code class="xref c c-func docutils literal notranslate"><span class="pre">localeconv()</span></code> 的 <code class="docutils literal notranslate"><span class="pre">decimal_point</span></code> 和 <code class="docutils literal notranslate"><span class="pre">thousands_sep</span></code> 字段，如果它们是非 ASCII 字符或长度超过 1 字节的话，并且 <code class="docutils literal notranslate"><span class="pre">LC_NUMERIC</span></code> 区域会与 <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> 区域不一致。 这个临时更改会影响其他线程。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.7 版更改: </span>当使用 <code class="docutils literal notranslate"><span class="pre">n</span></code> 类型格式化数字时，该函数在某些情况下会临时性地将 <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> 区域设置为 <code class="docutils literal notranslate"><span class="pre">LC_NUMERIC</span></code> 区域。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.format_map">
<code class="descclassname">str.</code><code class="descname">format_map</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#str.format_map" title="永久链接至目标">¶</a></dt>
<dd><p>类似于 <code class="docutils literal notranslate"><span class="pre">str.format(**mapping)</span></code>，不同之处在于 <code class="docutils literal notranslate"><span class="pre">mapping</span></code> 会被直接使用而不是复制到一个 <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>。 适宜使用此方法的一个例子是当 <code class="docutils literal notranslate"><span class="pre">mapping</span></code> 为 dict 的子类的情况：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Default</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">key</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1"> was born in </span><span class="si">{country}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format_map</span><span class="p">(</span><span class="n">Default</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Guido&#39;</span><span class="p">))</span>
<span class="go">&#39;Guido was born in country&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.index">
<code class="descclassname">str.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.index" title="永久链接至目标">¶</a></dt>
<dd><p>类似于 <a class="reference internal" href="#str.find" title="str.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a>，但在找不到子类时会引发 <a class="reference internal" href="exceptions.html#ValueError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
</dd></dl>

<dl class="method">
<dt id="str.isalnum">
<code class="descclassname">str.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isalnum" title="永久链接至目标">¶</a></dt>
<dd><p>如果字符串中至少有一个字符且所有字符均为字母或数字则返回真值，否则返回假值。 如果以下方法中的一个返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 则字符 <code class="docutils literal notranslate"><span class="pre">c</span></code> 为字母或数字: <code class="docutils literal notranslate"><span class="pre">c.isalpha()</span></code>, <code class="docutils literal notranslate"><span class="pre">c.isdecimal()</span></code>, <code class="docutils literal notranslate"><span class="pre">c.isdigit()</span></code>, or <code class="docutils literal notranslate"><span class="pre">c.isnumeric()</span></code>。</p>
</dd></dl>

<dl class="method">
<dt id="str.isalpha">
<code class="descclassname">str.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isalpha" title="永久链接至目标">¶</a></dt>
<dd><p>如果字符串中至少有一个字符且所有字符均为字母则返回真值，否则返回假值。 字母类字符是在 Unicode 字符数据库中被定义为 &quot;Letter&quot; 的字符，即一般分类特征属性为 &quot;Lm&quot;, &quot;Lt&quot;, &quot;Lu&quot;, &quot;Ll&quot; 或 &quot;Lo&quot; 其中之一。 请注意这不同于 Unicode 标准所定义的 &quot;Alphabetic&quot; 特征属性。</p>
</dd></dl>

<dl class="method">
<dt id="str.isascii">
<code class="descclassname">str.</code><code class="descname">isascii</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isascii" title="永久链接至目标">¶</a></dt>
<dd><p>如果字符串为空或所有字符均为 ASCII 字符则返回真值，否则返回假值。 ASCII 字符的码位范围为 U+0000-U+007F。</p>
<div class="versionadded">
<p><span class="versionmodified">3.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.isdecimal">
<code class="descclassname">str.</code><code class="descname">isdecimal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isdecimal" title="永久链接至目标">¶</a></dt>
<dd><p>如果字符串中至少有一个字符且所有字符均为十进制数字符则返回真值，否则返回假值。 十进制数字符是以 10 为基数的计数制会用来组成数值的字符，例如 U+0660, ARABIC-INDIC DIGIT ZERO。 正式的定义为：十进制数字符就是 Unicode 一般分类 &quot;Nd&quot; 中的字符。</p>
</dd></dl>

<dl class="method">
<dt id="str.isdigit">
<code class="descclassname">str.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isdigit" title="永久链接至目标">¶</a></dt>
<dd><p>如果字符串中至少有一个字符且所有字符均为数字字符则返回真值，否则返回假值。 数字字符包括十进制数字符和需要特别处理的数字，例如兼容性上标数字。 这也涵盖了不能被用来组成以 10 为基数的数值的数字，例如 Kharosthi 数字。 正式的定义为：数字字符就是特征属性值 Numeric_Type=Digit 或 Numeric_Type=Decimal 的字符。</p>
</dd></dl>

<dl class="method">
<dt id="str.isidentifier">
<code class="descclassname">str.</code><code class="descname">isidentifier</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isidentifier" title="永久链接至目标">¶</a></dt>
<dd><p>如果字符串根据语言定义属于有效的标识符则返回真值，参见 <a class="reference internal" href="lexical_analysis.html#identifiers" tppabs="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#identifiers"><span class="std std-ref">标识符和关键字</span></a>。</p>
<p>请使用 <a class="reference internal" href="keyword.html#keyword.iskeyword" tppabs="https://docs.python.org/zh-cn/3/library/keyword.html#keyword.iskeyword" title="keyword.iskeyword"><code class="xref py py-func docutils literal notranslate"><span class="pre">keyword.iskeyword()</span></code></a> 来检测保留标识符，例如 <a class="reference internal" href="compound_stmts.html#def" tppabs="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a> 和 <a class="reference internal" href="compound_stmts.html#class" tppabs="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a>。</p>
</dd></dl>

<dl class="method">
<dt id="str.islower">
<code class="descclassname">str.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.islower" title="永久链接至目标">¶</a></dt>
<dd><p>如果字符串中至少有一个区分大小写的字符 <a class="footnote-reference" href="#id15" id="id6">[4]</a> 且此类字符均为小写则返回真值，否则返回假值。</p>
</dd></dl>

<dl class="method">
<dt id="str.isnumeric">
<code class="descclassname">str.</code><code class="descname">isnumeric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isnumeric" title="永久链接至目标">¶</a></dt>
<dd><p>如果字符串中至少有一个字符且所有字符均为数值字符则返回真值，否则返回假值。 数值字符包括数字字符，以及所有在 Unicode 中设置了数值特性属性的字符，例如 U+2155, VULGAR FRACTION ONE FIFTH。 正式的定义为：数值字符就是具有特征属性值 Numeric_Type=Digit, Numeric_Type=Decimal 或 Numeric_Type=Numeric 的字符。</p>
</dd></dl>

<dl class="method">
<dt id="str.isprintable">
<code class="descclassname">str.</code><code class="descname">isprintable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isprintable" title="永久链接至目标">¶</a></dt>
<dd><p>如果字符串中所有字符均为可打印字符或字符串为空则返回真值，否则返回假值。 不可打印字符是在 Unicode 字符数据库中被定义为 &quot;Other&quot; 或 &quot;Separator&quot; 的字符，例外情况是 ASCII 空格字符 (0x20) 被视作可打印字符。 （请注意在此语境下可打印字符是指当对一个字符串发起调用 <a class="reference internal" href="functions.html#repr" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 时不必被转义的字符。 它们与字符串写入 <a class="reference internal" href="sys.html#sys.stdout" tppabs="https://docs.python.org/zh-cn/3/library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a> 或 <a class="reference internal" href="sys.html#sys.stderr" tppabs="https://docs.python.org/zh-cn/3/library/sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> 时所需的处理无关。）</p>
</dd></dl>

<dl class="method">
<dt id="str.isspace">
<code class="descclassname">str.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isspace" title="永久链接至目标">¶</a></dt>
<dd><p>如果字符串中至少有一个字符且所有字符均为空白字符则返回真值，否则返回假值。 空白字符是在 Unicode 字符数据库中被定义为 &quot;Other&quot; 或 &quot;Separator&quot; 并且其双向特征属性为 &quot;WS&quot;, &quot;B&quot; 或 &quot;S&quot; 之一的字符。</p>
</dd></dl>

<dl class="method">
<dt id="str.istitle">
<code class="descclassname">str.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.istitle" title="永久链接至目标">¶</a></dt>
<dd><p>如果字符串中至少有一个字符且为标题字符串则返回真值，例如大写字符之后只能带非大写字符而小写字符必须有大写字符打头。 否则返回假值。</p>
</dd></dl>

<dl class="method">
<dt id="str.isupper">
<code class="descclassname">str.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isupper" title="永久链接至目标">¶</a></dt>
<dd><p>如果字符串中至少有一个区分大小写的字符 <a class="footnote-reference" href="#id15" id="id7">[4]</a> 具此类字符均为大写则返回真值，否则返回假值。</p>
</dd></dl>

<dl class="method">
<dt id="str.join">
<code class="descclassname">str.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#str.join" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个由 <em>iterable</em> 中的字符串拼接而成的字符串。 如果 <em>iterable</em> 中存在任何非字符串值包括 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象则会引发 <a class="reference internal" href="exceptions.html#TypeError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 调用该方法的字符串将作为元素之间的分隔。</p>
</dd></dl>

<dl class="method">
<dt id="str.ljust">
<code class="descclassname">str.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.ljust" title="永久链接至目标">¶</a></dt>
<dd><p>返回长度为 <em>width</em> 的字符串，原字符串在其中靠左对齐。 使用指定的 <em>fillchar</em> 填充空位 (默认使用 ASCII 空格符)。 如果 <em>width</em> 小于等于 <code class="docutils literal notranslate"><span class="pre">len(s)</span></code> 则返回原字符串的副本。</p>
</dd></dl>

<dl class="method">
<dt id="str.lower">
<code class="descclassname">str.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.lower" title="永久链接至目标">¶</a></dt>
<dd><p>返回原字符串的副本，其所有区分大小写的字符 <a class="footnote-reference" href="#id15" id="id8">[4]</a> 均转换为小写。</p>
<p>所用转换小写算法的描述请参见 Unicode 标准的 3.13 节。</p>
</dd></dl>

<dl class="method">
<dt id="str.lstrip">
<code class="descclassname">str.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.lstrip" title="永久链接至目标">¶</a></dt>
<dd><p>返回原字符串的副本，移除其中的前导字符。 <em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则 <em>chars</em> 参数默认移除空格符。 实际上 <em>chars</em> 参数并非指定单个前缀；而是会移除参数值的所有组合:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">&#39;spacious   &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">&#39;example.com&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="str.maketrans">
<em class="property">static </em><code class="descclassname">str.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>x</em><span class="optional">[</span>, <em>y</em><span class="optional">[</span>, <em>z</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.maketrans" title="永久链接至目标">¶</a></dt>
<dd><p>此静态方法返回一个可供 <a class="reference internal" href="#str.translate" title="str.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.translate()</span></code></a> 使用的转换对照表。</p>
<p>如果只有一个参数，则它必须是一个将 Unicode 码位序号（整数）或字符（长度为 1 的字符串）映射到 Unicode 码位序号、（任意长度的）字符串或 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的字典。 字符键将会被转换为码位序号。</p>
<p>如果有两个参数，则它们必须是两个长度相等的字符串，并且在结果字典中，x 中每个字符将被映射到 y 中相同位置的字符。 如果有第三个参数，它必须是一个字符串，其中的字符将在结果中被映射到 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

<dl class="method">
<dt id="str.partition">
<code class="descclassname">str.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#str.partition" title="永久链接至目标">¶</a></dt>
<dd><p>在 <em>sep</em> 首次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含字符本身以及两个空字符串。</p>
</dd></dl>

<dl class="method">
<dt id="str.replace">
<code class="descclassname">str.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.replace" title="永久链接至目标">¶</a></dt>
<dd><p>返回字符串的副本，其中出现的所有子字符串 <em>old</em> 都将被替换为 <em>new</em>。 如果给出了可选参数 <em>count</em>，则只替换前 <em>count</em> 次出现。</p>
</dd></dl>

<dl class="method">
<dt id="str.rfind">
<code class="descclassname">str.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rfind" title="永久链接至目标">¶</a></dt>
<dd><p>返回子字符串 <em>sub</em> 在字符串内被找到的最大（最右）索引，这样 <em>sub</em> 将包含在 <code class="docutils literal notranslate"><span class="pre">s[start:end]</span></code> 当中。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果未找到则返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p>
</dd></dl>

<dl class="method">
<dt id="str.rindex">
<code class="descclassname">str.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rindex" title="永久链接至目标">¶</a></dt>
<dd><p>类似于 <a class="reference internal" href="#str.rfind" title="str.rfind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rfind()</span></code></a>，但在子字符串 <em>sub</em> 未找到时会引发 <a class="reference internal" href="exceptions.html#ValueError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
</dd></dl>

<dl class="method">
<dt id="str.rjust">
<code class="descclassname">str.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rjust" title="永久链接至目标">¶</a></dt>
<dd><p>返回长度为 <em>width</em> 的字符串，原字符串在其中靠右对齐。 使用指定的 <em>fillchar</em> 填充空位 (默认使用 ASCII 空格符)。 如果 <em>width</em> 小于等于 <code class="docutils literal notranslate"><span class="pre">len(s)</span></code> 则返回原字符串的副本。</p>
</dd></dl>

<dl class="method">
<dt id="str.rpartition">
<code class="descclassname">str.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#str.rpartition" title="永久链接至目标">¶</a></dt>
<dd><p>在 <em>sep</em> 最后一次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空字符串以及字符串本身。</p>
</dd></dl>

<dl class="method">
<dt id="str.rsplit">
<code class="descclassname">str.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#str.rsplit" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个由字符串内单词组成的列表，使用 <em>sep</em> 作为分隔字符串。 如果给出了 <em>maxsplit</em>，则最多进行 <em>maxsplit</em> 次拆分，从 <em>最右边</em> 开始。 如果 <em>sep</em> 未指定或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，任何空白字符串都会被作为分隔符。 除了从右边开始拆分，<a class="reference internal" href="#str.rsplit" title="str.rsplit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rsplit()</span></code></a> 的其他行为都类似于下文所述的 <a class="reference internal" href="#str.split" title="str.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a>。</p>
</dd></dl>

<dl class="method">
<dt id="str.rstrip">
<code class="descclassname">str.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rstrip" title="永久链接至目标">¶</a></dt>
<dd><p>返回原字符串的副本，移除其中的末尾字符。 <em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则 <em>chars</em> 参数默认移除空格符。 实际上 <em>chars</em> 参数并非指定单个后缀；而是会移除参数值的所有组合:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">&#39;   spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;mississippi&#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;ipz&#39;</span><span class="p">)</span>
<span class="go">&#39;mississ&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.split">
<code class="descclassname">str.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#str.split" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个由字符串内单词组成的列表，使用 <em>sep</em> 作为分隔字符串。 如果给出了 <em>maxsplit</em>，则最多进行 <em>maxsplit</em> 次拆分（因此，列表最多会有 <code class="docutils literal notranslate"><span class="pre">maxsplit+1</span></code> 个元素）。 如果 <em>maxsplit</em> 未指定或为 <code class="docutils literal notranslate"><span class="pre">-1</span></code>，则不限制拆分次数（进行所有可能的拆分）。</p>
<p>如果给出了 <em>sep</em>，则连续的分隔符不会被组合在一起而是被视为分隔空字符串 (例如 <code class="docutils literal notranslate"><span class="pre">'1,,2'.split(',')</span></code> 将返回 <code class="docutils literal notranslate"><span class="pre">['1',</span> <span class="pre">'',</span> <span class="pre">'2']</span></code>)。 <em>sep</em> 参数可能由多个字符组成 (例如 <code class="docutils literal notranslate"><span class="pre">'1&lt;&gt;2&lt;&gt;3'.split('&lt;&gt;')</span></code> 将返回 <code class="docutils literal notranslate"><span class="pre">['1',</span> <span class="pre">'2',</span> <span class="pre">'3']</span></code>)。 使用指定的分隔符拆分空字符串将返回 <code class="docutils literal notranslate"><span class="pre">['']</span></code>。</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2,3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,,3,&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;&#39;, &#39;3&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p>如果 <em>sep</em> 未指定或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则会应用另一种拆分算法：连续的空格会被视为单个分隔符，其结果将不包含开头或末尾的空字符串，如果字符串包含前缀或后缀空格的话。 因此，使用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 拆分空字符串或仅包含空格的字符串将返回 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2 3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   1   2   3   &#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="index-32"></span><dl class="method">
<dt id="str.splitlines">
<code class="descclassname">str.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><span class="optional">[</span><em>keepends</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.splitlines" title="永久链接至目标">¶</a></dt>
<dd><p>返回由原字符串中各行组成的列表，在行边界的位置拆分。 结果列表中不包含行边界，除非给出了 <em>keepends</em> 且为真值。</p>
<p>此方法会以下列行边界进行拆分。 特别地，行边界是 <a class="reference internal" href="glossary.html#term-universal-newlines" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> 的一个超集。</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">表示符</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\n</span></code></td>
<td>换行</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\r</span></code></td>
<td>回车</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\r\n</span></code></td>
<td>回车 + 换行</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\v</span></code> 或 <code class="docutils literal notranslate"><span class="pre">\x0b</span></code></td>
<td>行制表符</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\f</span></code> 或 <code class="docutils literal notranslate"><span class="pre">\x0c</span></code></td>
<td>换表单</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\x1c</span></code></td>
<td>文件分隔符</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\x1d</span></code></td>
<td>组分隔符</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\x1e</span></code></td>
<td>记录分隔符</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\x85</span></code></td>
<td>下一行 (C1 控制码)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\u2028</span></code></td>
<td>行分隔符</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\u2029</span></code></td>
<td>段分隔符</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">在 3.2 版更改: </span><code class="docutils literal notranslate"><span class="pre">\v</span></code> 和 <code class="docutils literal notranslate"><span class="pre">\f</span></code> 被添加到行边界列表</p>
</div>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[&#39;ab c&#39;, &#39;&#39;, &#39;de fg&#39;, &#39;kl&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[&#39;ab c\n&#39;, &#39;\n&#39;, &#39;de fg\r&#39;, &#39;kl\r\n&#39;]</span>
</pre></div>
</div>
<p>不同于 <a class="reference internal" href="#str.split" title="str.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a>，当给出了分隔字符串 <em>sep</em> 时，对于空字符串此方法将返回一个空列表，而末尾的换行不会令结果中增加额外的行:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;One line</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[&#39;One line&#39;]</span>
</pre></div>
</div>
<p>作为比较，<code class="docutils literal notranslate"><span class="pre">split('\n')</span></code> 的结果为:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Two lines</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;Two lines&#39;, &#39;&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.startswith">
<code class="descclassname">str.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.startswith" title="永久链接至目标">¶</a></dt>
<dd><p>如果字符串以指定的 <em>prefix</em> 开始则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 <em>prefix</em> 也可以为由多个供查找的前缀构成的元组。 如果有可选项 <em>start</em>，将从所指定位置开始检查。 如果有可选项 <em>end</em>，将在所指定位置停止比较。</p>
</dd></dl>

<dl class="method">
<dt id="str.strip">
<code class="descclassname">str.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.strip" title="永久链接至目标">¶</a></dt>
<dd><p>返回原字符串的副本，移除其中的前导和末尾字符。 <em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则 <em>chars</em> 参数默认移除空格符。 实际上 <em>chars</em> 参数并非指定单个前缀或后缀；而是会移除参数值的所有组合:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">&#39;spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">&#39;example&#39;</span>
</pre></div>
</div>
<p>最外侧的前导和末尾 <em>chars</em> 参数值将从字符串中移除。 开头端的字符的移除将在遇到一个未包含于 <em>chars</em> 所指定字符集的字符时停止。 类似的操作也将在结尾端发生。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">comment_string</span> <span class="o">=</span> <span class="s1">&#39;#....... Section 3.2.1 Issue #32 .......&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comment_string</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;.#! &#39;</span><span class="p">)</span>
<span class="go">&#39;Section 3.2.1 Issue #32&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.swapcase">
<code class="descclassname">str.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.swapcase" title="永久链接至目标">¶</a></dt>
<dd><p>返回原字符串的副本，其中大写字符转换为小写，反之亦然。 请注意 <code class="docutils literal notranslate"><span class="pre">s.swapcase().swapcase()</span> <span class="pre">==</span> <span class="pre">s</span></code> 并不一定为真值。</p>
</dd></dl>

<dl class="method">
<dt id="str.title">
<code class="descclassname">str.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.title" title="永久链接至目标">¶</a></dt>
<dd><p>返回原字符串的标题版本，其中每个单词第一个字母为大写，其余字母为小写。</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 该定义在多数情况下都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望的结果:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;they&#39;re bill&#39;s friends from the UK&quot;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">&quot;They&#39;Re Bill&#39;S Friends From The Uk&quot;</span>
</pre></div>
</div>
<p>可以使用正则表达式来构建针对撇号的特别处理:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">titlecase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[A-Za-z]+(&#39;[A-Za-z]+)?&quot;</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="k">lambda</span> <span class="n">mo</span><span class="p">:</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span>
<span class="gp">... </span>                             <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
<span class="gp">... </span>                  <span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">titlecase</span><span class="p">(</span><span class="s2">&quot;they&#39;re bill&#39;s friends.&quot;</span><span class="p">)</span>
<span class="go">&quot;They&#39;re Bill&#39;s Friends.&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.translate">
<code class="descclassname">str.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em><span class="sig-paren">)</span><a class="headerlink" href="#str.translate" title="永久链接至目标">¶</a></dt>
<dd><p>返回原字符串的副本，其中每个字符按给定的转换表进行映射。 转换表必须是一个使用 <a class="reference internal" href="datamodel.html#object.__getitem__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 来实现索引操作的对象，通常为 <a class="reference internal" href="glossary.html#term-mapping" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a> 或 <a class="reference internal" href="glossary.html#term-sequence" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a>。 当以 Unicode 码位序号（整数）为索引时，转换表对象可以做以下任何一种操作：返回 Unicode 序号或字符串，将字符映射为一个或多个字符；返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>，将字符从结果字符串中删除；或引发 <a class="reference internal" href="exceptions.html#LookupError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> 异常，将字符映射为其自身。</p>
<p>你可以使用 <a class="reference internal" href="#str.maketrans" title="str.maketrans"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.maketrans()</span></code></a> 基于不同格式的字符到字符映射来创建一个转换映射表。</p>
<p>另请参阅 <a class="reference internal" href="codecs.html#module-codecs" tppabs="https://docs.python.org/zh-cn/3/library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> 模块以了解定制字符映射的更灵活方式。</p>
</dd></dl>

<dl class="method">
<dt id="str.upper">
<code class="descclassname">str.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.upper" title="永久链接至目标">¶</a></dt>
<dd><p>返回原字符串的副本，其中所有区分大小写的字符 <a class="footnote-reference" href="#id15" id="id9">[4]</a> 均转换为大写。 请注意如果 <code class="docutils literal notranslate"><span class="pre">s</span></code> 包含不区分大小写的字符或者如果结果字符的 Unicode 类别不是 &quot;Lu&quot; (Letter, uppercase) 而是 &quot;Lt&quot; (Letter, titlecase) 则 <code class="docutils literal notranslate"><span class="pre">s.upper().isupper()</span></code> 有可能为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<p>所用转换大写算法的描述请参见 Unicode 标准的 3.13 节。</p>
</dd></dl>

<dl class="method">
<dt id="str.zfill">
<code class="descclassname">str.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#str.zfill" title="永久链接至目标">¶</a></dt>
<dd><p>返回原字符串的副本，在左边填充 ASCII <code class="docutils literal notranslate"><span class="pre">'0'</span></code> 数码使其长度变为 <em>width</em>。 正负值前缀 (<code class="docutils literal notranslate"><span class="pre">'+'</span></code>/<code class="docutils literal notranslate"><span class="pre">'-'</span></code>) 的处理方式是在正负符号 <em>之后</em> 填充而非在之前。 如果 <em>width</em> 小于等于 <code class="docutils literal notranslate"><span class="pre">len(s)</span></code> 则返回原字符串的副本。</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;00042&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;-42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;-0042&#39;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="printf-style-string-formatting">
<span id="old-string-formatting"></span><h3><code class="docutils literal notranslate"><span class="pre">printf</span></code> 风格的字符串格式化<a class="headerlink" href="#printf-style-string-formatting" title="永久链接至标题">¶</a></h3>
<div class="admonition note" id="index-33">
<p class="first admonition-title">注解</p>
<p class="last">此处介绍的格式化操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示元组和字典）。 使用较新的 <a class="reference internal" href="lexical_analysis.html#f-strings" tppabs="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings"><span class="std std-ref">格式化字符串字面值</span></a>，<a class="reference internal" href="#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 接口或 <a class="reference internal" href="string.html#template-strings" tppabs="https://docs.python.org/zh-cn/3/library/string.html#template-strings"><span class="std std-ref">模板字符串</span></a> 有助于避免这样的错误。 这些替代方案中的每一种都更好地权衡并提供了简单、灵活以及可扩展性优势。</p>
</div>
<p>字符串具有一种特殊的内置操作：使用 <code class="docutils literal notranslate"><span class="pre">%</span></code> (取模) 运算符。 这也被称为字符串的 <em>格式化</em> 或 <em>插值</em> 运算符。 对于 <code class="docutils literal notranslate"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">values</span></code> (其中 <em>format</em> 为一个字符串)，在 <em>format</em> 中的 <code class="docutils literal notranslate"><span class="pre">%</span></code> 转换标记符将被替换为零个或多个 <em>values</em> 条目。 其效果类似于 在 C 语言中使用 <code class="xref c c-func docutils literal notranslate"><span class="pre">sprintf()</span></code>。</p>
<p>如果 <em>format</em> 要求一个单独参数，则 <em>values</em> 可以为一个非元组对象。 <a class="footnote-reference" href="#id16" id="id10">[5]</a>  否则的话，<em>values</em> 必须或者是一个包含项数与格式字符串中指定的转换符项数相同的元组，或者是一个单独映射对象（例如字典）。</p>
<p id="index-34">转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">'%'</span></code> 字符，用于标记转换符的起始。</li>
<li>映射键（可选），由加圆括号的字符序列组成 (例如 <code class="docutils literal notranslate"><span class="pre">(somename)</span></code>)。</li>
<li>转换旗标（可选），用于影响某些转换类型的结果。</li>
<li>最小字段宽度（可选）。 如果指定为 <code class="docutils literal notranslate"><span class="pre">'*'</span></code> (星号)，则实际宽度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。</li>
<li>精度（可选），以在 <code class="docutils literal notranslate"><span class="pre">'.'</span></code> (点号) 之后加精度值的形式给出。 如果指定为 <code class="docutils literal notranslate"><span class="pre">'*'</span></code> (星号)，则实际精度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为精度之后的元素。</li>
<li>长度修饰符（可选）。</li>
<li>转换类型。</li>
</ol>
<p>当右边的参数为一个字典（或其他映射类型）时，字符串中的格式 <em>must</em> 必须包含加圆括号的映射键，对应 <code class="docutils literal notranslate"><span class="pre">'%'</span></code> 字符之后字典中的每一项。 映射键将从映射中选取要格式化的值。 例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(language)s</span><span class="s1"> has </span><span class="si">%(number)03d</span><span class="s1"> quote types.&#39;</span> <span class="o">%</span>
<span class="gp">... </span>      <span class="p">{</span><span class="s1">&#39;language&#39;</span><span class="p">:</span> <span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">Python has 002 quote types.</span>
</pre></div>
</div>
<p>在此情况下格式中不能出现 <code class="docutils literal notranslate"><span class="pre">*</span></code> 标记符（因其需要一个序列类的参数列表）。</p>
<p>转换旗标为：</p>
<table border="1" class="docutils" id="index-35">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">标志</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'#'</span></code></td>
<td>值的转换将使用“替代形式”（具体定义见下文）。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'0'</span></code></td>
<td>转换将为数字值填充零字符。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'-'</span></code></td>
<td>转换值将靠左对齐（如果同时给出 <code class="docutils literal notranslate"><span class="pre">'0'</span></code> 转换，则会覆盖后者）。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">'</span></code></td>
<td>(空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'+'</span></code></td>
<td>符号字符 (<code class="docutils literal notranslate"><span class="pre">'+'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'-'</span></code>) 将显示于转换结果的开头（会覆盖 &quot;空格&quot; 旗标）。</td>
</tr>
</tbody>
</table>
<p>可以给出长度修饰符 (<code class="docutils literal notranslate"><span class="pre">h</span></code>, <code class="docutils literal notranslate"><span class="pre">l</span></code> 或 <code class="docutils literal notranslate"><span class="pre">L</span></code>)，但会被忽略，因为对 Python 来说没有必要 -- 所以 <code class="docutils literal notranslate"><span class="pre">%ld</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">%d</span></code>。</p>
<p>转换类型为：</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="74%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">转换符</th>
<th class="head">含义</th>
<th class="head">注释</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'d'</span></code></td>
<td>有符号十进制整数。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'i'</span></code></td>
<td>有符号十进制整数。</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'o'</span></code></td>
<td>有符号八进制数。</td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'u'</span></code></td>
<td>过时类型 -- 等价于 <code class="docutils literal notranslate"><span class="pre">'d'</span></code>。</td>
<td>(6)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'x'</span></code></td>
<td>有符号十六进制数（小写）。</td>
<td>(2)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'X'</span></code></td>
<td>有符号十六进制数（大写）。</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'e'</span></code></td>
<td>浮点指数格式（小写）。</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'E'</span></code></td>
<td>浮点指数格式（大写）。</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'f'</span></code></td>
<td>浮点十进制格式。</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'F'</span></code></td>
<td>浮点十进制格式。</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'g'</span></code></td>
<td>浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。</td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'G'</span></code></td>
<td>浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。</td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'c'</span></code></td>
<td>单个字符（接受整数或单个字符的字符串）。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'r'</span></code></td>
<td>字符串（使用 <a class="reference internal" href="functions.html#repr" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 转换任何 Python 对象）。</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'s'</span></code></td>
<td>字符串（使用 <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 转换任何 Python 对象）。</td>
<td>(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'a'</span></code></td>
<td>字符串（使用 <a class="reference internal" href="functions.html#ascii" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a> 转换任何 Python 对象）。</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'%'</span></code></td>
<td>不转换参数，在结果中输出一个 <code class="docutils literal notranslate"><span class="pre">'%'</span></code> 字符。</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>注释:</p>
<ol class="arabic">
<li><p class="first">此替代形式会在第一个数码之前插入标示八进制数的前缀 (<code class="docutils literal notranslate"><span class="pre">'0o'</span></code>)。</p>
</li>
<li><p class="first">此替代形式会在第一个数码之前插入 <code class="docutils literal notranslate"><span class="pre">'0x'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'0X'</span></code> 前缀（取决于是使用 <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 还是 <code class="docutils literal notranslate"><span class="pre">'X'</span></code> 格式）。</p>
</li>
<li><p class="first">此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。</p>
<p>小数点后的数码位数由精度决定，默认为 6。</p>
</li>
<li><p class="first">此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。</p>
<p>小数点前后的有效数码位数由精度决定，默认为 6。</p>
</li>
<li><p class="first">如果精度为 <code class="docutils literal notranslate"><span class="pre">N</span></code>，输出将截短为 <code class="docutils literal notranslate"><span class="pre">N</span></code> 个字符。</p>
</li>
<li><p class="first">参见 <span class="target" id="index-62"></span><a class="pep reference external" href="javascript:if(confirm('https://www.python.org/dev/peps/pep-0237  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://www.python.org/dev/peps/pep-0237'" tppabs="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a>。</p>
</li>
</ol>
<p>由于 Python 字符串显式指明长度，<code class="docutils literal notranslate"><span class="pre">%s</span></code> 转换不会将 <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> 视为字符串的结束。</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.1 版更改: </span>绝对值超过 1e50 的 <code class="docutils literal notranslate"><span class="pre">%f</span></code> 转换不会再被替换为 <code class="docutils literal notranslate"><span class="pre">%g</span></code> 转换。</p>
</div>
</div>
</div>
<div class="section" id="binary-sequence-types-bytes-bytearray-memoryview">
<span id="binaryseq"></span><span id="index-37"></span><h2>二进制序列类型 --- <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a><a class="headerlink" href="#binary-sequence-types-bytes-bytearray-memoryview" title="永久链接至标题">¶</a></h2>
<p id="index-38">操作二进制数据的核心内置类型是 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 和 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>。 它们由 <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 提供支持，该对象使用 <a class="reference internal" href="buffer.html#bufferobjects" tppabs="https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects"><span class="std std-ref">缓冲区协议</span></a> 来访问其他二进制对象所在内存，不需要创建对象的副本。</p>
<p><a class="reference internal" href="array.html#module-array" tppabs="https://docs.python.org/zh-cn/3/library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> 模块支持高效地存储基本数据类型，例如 32 位整数和 IEEE754 双精度浮点值。</p>
<div class="section" id="bytes-objects">
<span id="typebytes"></span><h3>bytes 对象<a class="headerlink" href="#bytes-objects" title="永久链接至标题">¶</a></h3>
<p id="index-39">bytes 对象是由单个字节构成的不可变序列。 由于许多主要二进制协议都基于 ASCII 文本编码，因此 bytes 对象提供了一些仅在处理 ASCII 兼容数据时可用，并且在许多特性上与字符串对象紧密相关的方法。</p>
<dl class="class">
<dt id="bytes">
<em class="property">class </em><code class="descname">bytes</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes" title="永久链接至目标">¶</a></dt>
<dd><p>首先，表示 bytes 字面值的语法与字符串字面值的大致相同，只是添加了一个 <code class="docutils literal notranslate"><span class="pre">b</span></code> 前缀：</p>
<ul class="simple">
<li>单引号: <code class="docutils literal notranslate"><span class="pre">b'同样允许嵌入</span> <span class="pre">&quot;双&quot;</span> <span class="pre">引号'</span></code>。</li>
<li>双引号: <code class="docutils literal notranslate"><span class="pre">b&quot;同样允许嵌入</span> <span class="pre">'单'</span> <span class="pre">引号&quot;</span></code>。</li>
<li>三重引号: <code class="docutils literal notranslate"><span class="pre">b'''三重单引号'''</span></code>, <code class="docutils literal notranslate"><span class="pre">b&quot;&quot;&quot;三重双引号&quot;&quot;&quot;</span></code></li>
</ul>
<p>bytes 字面值中只允许 ASCII 字符（无论源代码声明的编码为何）。 任何超出 127 的二进制值必须使用相应的转义序列形式加入 bytes 字面值。</p>
<p>像字符串字面值一样，bytes 字面值也可以使用 <code class="docutils literal notranslate"><span class="pre">r</span></code> 前缀来禁用转义序列处理。 请参阅 <a class="reference internal" href="lexical_analysis.html#strings" tppabs="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#strings"><span class="std std-ref">字符串和字节串字面值</span></a> 了解有关各种 bytes 字面值形式的详情，包括所支持的转义序列。</p>
<p>虽然 bytes 字面值和表示法是基于 ASCII 文本的，但 bytes 对象的行为实际上更像是不可变的整数序列，序列中的每个值的大小被限制为 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> (如果违反此限制将引发 <a class="reference internal" href="exceptions.html#ValueError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>)。 这种限制是有意设计用以强调以下事实，虽然许多二进制格式都包含基于 ASCII 的元素，可以通过某些面向文本的算法进行有用的操作，但情况对于任意二进制数据来说通常却并非如此（盲目地将文本处理算法应用于不兼容 ASCII 的二进制数据格式往往将导致数据损坏）。</p>
<p>除了字面值形式，bytes 对象还可以通过其他几种方式来创建：</p>
<ul class="simple">
<li>指定长度的以零值填充的 bytes 对象: <code class="docutils literal notranslate"><span class="pre">bytes(10)</span></code></li>
<li>通过由整数组成的可迭代对象: <code class="docutils literal notranslate"><span class="pre">bytes(range(20))</span></code></li>
<li>通过缓冲区协议复制现有的二进制数据:  <code class="docutils literal notranslate"><span class="pre">bytes(obj)</span></code></li>
</ul>
<p>另请参阅 <a class="reference internal" href="functions.html#func-bytes" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#func-bytes"><span class="std std-ref">bytes</span></a> 内置类型。</p>
<p>由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相应地，bytes 类型具有从此种格式读取数据的附加类方法：</p>
<dl class="classmethod">
<dt id="bytes.fromhex">
<em class="property">classmethod </em><code class="descname">fromhex</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.fromhex" title="永久链接至目标">¶</a></dt>
<dd><p>此 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 类方法返回一个解码给定字符串的 bytes 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;2Ef0 F1f2  &#39;</span><span class="p">)</span>
<span class="go">b&#39;.\xf0\xf1\xf2&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.7 版更改: </span><a class="reference internal" href="#bytes.fromhex" title="bytes.fromhex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.fromhex()</span></code></a> 现在会忽略所有 ASCII 空白符而不只是空格符。</p>
</div>
</dd></dl>

<p>存在一个反向转换函数，可以将 bytes 对象转换为对应的十六进制表示。</p>
<dl class="method">
<dt id="bytes.hex">
<code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.hex" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xf0\xf1\xf2</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;f0f1f2&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.5 新版功能.</span></p>
</div>
</dd></dl>

</dd></dl>

<p>由于 bytes 对象是由整数构成的序列（类似于元组），因此对于一个 bytes 对象 <em>b</em>，<code class="docutils literal notranslate"><span class="pre">b[0]</span></code> 将为一个整数，而 <code class="docutils literal notranslate"><span class="pre">b[0:1]</span></code> 将为一个长度为 1 的 bytes 对象。 （这与文本字符串不同，索引和切片所产生的将都是一个长度为 1 的字符串）。</p>
<p>bytes 对象的表示使用字面值格式 (<code class="docutils literal notranslate"><span class="pre">b'...'</span></code>)，因为它通常都要比像 <code class="docutils literal notranslate"><span class="pre">bytes([46,</span> <span class="pre">46,</span> <span class="pre">46])</span></code> 这样的格式更好用。 你总是可以使用 <code class="docutils literal notranslate"><span class="pre">list(b)</span></code> 将 bytes 对象转换为一个由整数构成的列表。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">针对 Python 2.x 用户的说明：在 Python 2.x 系列中，允许 8 位字符串（ 2.x 所提供的最接近内置二进制数据类型的对象）与 Unicode 字符串进行各种隐式转换。 这是为了实现向下兼容的变通做法，以适应 Python 最初只支持 8 位文本而 Unicode 文本是后来才被加入这一事实。 在 Python 3.x 中，这些隐式转换已被取消 —— 8 位二进制数据与 Unicode 文本间的转换必须显式地进行，bytes 与字符串对象的比较结果将总是不相等。</p>
</div>
</div>
<div class="section" id="bytearray-objects">
<span id="typebytearray"></span><h3>bytearray 对象<a class="headerlink" href="#bytearray-objects" title="永久链接至标题">¶</a></h3>
<p id="index-40"><a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 对象是 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象的可变对应物。</p>
<dl class="class">
<dt id="bytearray">
<em class="property">class </em><code class="descname">bytearray</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray" title="永久链接至目标">¶</a></dt>
<dd><p>bytearray 对象没有专属的字面值语法，它们总是通过调用构造器来创建：</p>
<ul class="simple">
<li>创建一个空实例: <code class="docutils literal notranslate"><span class="pre">bytearray()</span></code></li>
<li>创建一个指定长度的以零值填充的实例: <code class="docutils literal notranslate"><span class="pre">bytearray(10)</span></code></li>
<li>通过由整数组成的可迭代对象: <code class="docutils literal notranslate"><span class="pre">bytearray(range(20))</span></code></li>
<li>通过缓冲区协议复制现有的二进制数据:  <code class="docutils literal notranslate"><span class="pre">bytearray(b'Hi!')</span></code></li>
</ul>
<p>由于 bytearray 对象是可变的，该对象除了 <a class="reference internal" href="#bytes-methods"><span class="std std-ref">bytes 和 bytearray 操作</span></a> 中所描述的 bytes 和 bytearray 共有操作之外，还支持 <a class="reference internal" href="#typesseq-mutable"><span class="std std-ref">可变</span></a> 序列操作。</p>
<p>另请参见 <a class="reference internal" href="functions.html#func-bytearray" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#func-bytearray"><span class="std std-ref">bytearray</span></a> 内置类型。</p>
<p>由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相应地，bytearray 类型具有从此种格式读取数据的附加类方法：</p>
<dl class="classmethod">
<dt id="bytearray.fromhex">
<em class="property">classmethod </em><code class="descname">fromhex</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.fromhex" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 类方法返回一个解码给定字符串的 bytearray 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;2Ef0 F1f2  &#39;</span><span class="p">)</span>
<span class="go">bytearray(b&#39;.\xf0\xf1\xf2&#39;)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.7 版更改: </span><a class="reference internal" href="#bytearray.fromhex" title="bytearray.fromhex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytearray.fromhex()</span></code></a> 现在会忽略所有 ASCII 空白符而不只是空格符。</p>
</div>
</dd></dl>

<p>存在一个反向转换函数，可以将 bytearray 对象转换为对应的十六进制表示。</p>
<dl class="method">
<dt id="bytearray.hex">
<code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.hex" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xf0\xf1\xf2</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;f0f1f2&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.5 新版功能.</span></p>
</div>
</dd></dl>

</dd></dl>

<p>由于 bytearray 对象是由整数构成的序列（类似于列表），因此对于一个 bytearray 对象 <em>b</em>，<code class="docutils literal notranslate"><span class="pre">b[0]</span></code> 将为一个整数，而 <code class="docutils literal notranslate"><span class="pre">b[0:1]</span></code> 将为一个长度为 1 的 bytearray 对象。 （这与文本字符串不同，索引和切片所产生的将都是一个长度为 1 的字符串）。</p>
<p>bytearray 对象的表示使用 bytes 对象字面值格式 (<code class="docutils literal notranslate"><span class="pre">bytearray(b'...')</span></code>)，因为它通常都要比 <code class="docutils literal notranslate"><span class="pre">bytearray([46,</span> <span class="pre">46,</span> <span class="pre">46])</span></code> 这样的格式更好用。 你总是可以使用 <code class="docutils literal notranslate"><span class="pre">list(b)</span></code> 将 bytearray 对象转换为一个由整数构成的列表。</p>
</div>
<div class="section" id="bytes-and-bytearray-operations">
<span id="bytes-methods"></span><h3>bytes 和 bytearray 操作<a class="headerlink" href="#bytes-and-bytearray-operations" title="永久链接至标题">¶</a></h3>
<p id="index-41">bytes 和 bytearray 对象都支持 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">通用</span></a> 序列操作。 它们不仅能与相同类型的操作数，也能与任何 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 进行互操作。 由于这样的灵活性，它们可以在操作中自由地混合而不会导致错误。 但是，操作结果的返回值类型可能取决于操作数的顺序。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>bytes 和 bytearray 对象的方法不接受字符串作为其参数，就像字符串的方法不接受 bytes 对象作为其参数一样。 例如，你必须使用以下写法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;abc&quot;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>和:</p>
<div class="last highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;abc&quot;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>某些 bytes 和 bytearray 操作假定使用兼容 ASCII 的二进制格式，因此在处理任意二进数数据时应当避免使用。 这些限制会在下文中说明。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">使用这些基于 ASCII 的操作来处理未以基于 ASCII 的格式存储的二进制数据可能会导致数据损坏。</p>
</div>
<p>bytes 和 bytearray 对象的下列方法可以用于任意二进制数据。</p>
<dl class="method">
<dt id="bytes.count">
<code class="descclassname">bytes.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.count" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.count">
<code class="descclassname">bytearray.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.count" title="永久链接至目标">¶</a></dt>
<dd><p>返回子序列 <em>sub</em> 在 [<em>start</em>, <em>end</em>] 范围内非重叠出现的次数。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。</p>
<p>要搜索的子序列可以是任意 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 或是 0 至 255 范围内的整数。</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>也接受 0 至 255 范围内的整数作为子序列。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.decode">
<code class="descclassname">bytes.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>encoding=&quot;utf-8&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.decode" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.decode">
<code class="descclassname">bytearray.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>encoding=&quot;utf-8&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.decode" title="永久链接至目标">¶</a></dt>
<dd><p>返回从给定 bytes 解码出来的字符串。 默认编码为 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>。 可以给出 <em>errors</em> 来设置不同的错误处理方案。 <em>errors</em> 的默认值为 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>，表示编码错误会引发 <a class="reference internal" href="exceptions.html#UnicodeError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>。 其他可用的值为 <code class="docutils literal notranslate"><span class="pre">'ignore'</span></code>, <code class="docutils literal notranslate"><span class="pre">'replace'</span></code> 以及任何其他通过 <a class="reference internal" href="codecs.html#codecs.register_error" tppabs="https://docs.python.org/zh-cn/3/library/codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.register_error()</span></code></a> 注册的名称，请参阅 <a class="reference internal" href="codecs.html#error-handlers" tppabs="https://docs.python.org/zh-cn/3/library/codecs.html#error-handlers"><span class="std std-ref">Error Handlers</span></a> 小节。 要查看可用的编码列表，请参阅 <a class="reference internal" href="codecs.html#standard-encodings" tppabs="https://docs.python.org/zh-cn/3/library/codecs.html#standard-encodings"><span class="std std-ref">标准编码</span></a> 小节。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">将 <em>encoding</em> 参数传给 <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 允许直接解码任何 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>，无须创建临时的 bytes 或 bytearray 对象。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.1 版更改: </span>加入了对关键字参数的支持。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.endswith">
<code class="descclassname">bytes.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.endswith" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.endswith">
<code class="descclassname">bytearray.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.endswith" title="永久链接至目标">¶</a></dt>
<dd><p>如果二进制数据以指定的 <em>suffix</em> 结束则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 <em>suffix</em> 也可以为由多个供查找的后缀构成的元组。 如果有可选项 <em>start</em>，将从所指定位置开始检查。 如果有可选项 <em>end</em>，将在所指定位置停止比较。</p>
<p>要搜索的后缀可以是任意 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。</p>
</dd></dl>

<dl class="method">
<dt id="bytes.find">
<code class="descclassname">bytes.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.find" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.find">
<code class="descclassname">bytearray.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.find" title="永久链接至目标">¶</a></dt>
<dd><p>返回子序列 <em>sub</em> 在数据中被找到的最小索引，<em>sub</em> 包含于切片 <code class="docutils literal notranslate"><span class="pre">s[start:end]</span></code> 之内。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果 <em>sub</em> 未被找到则返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p>
<p>要搜索的子序列可以是任意 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 或是 0 至 255 范围内的整数。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p><a class="reference internal" href="#bytes.find" title="bytes.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> 方法应该只在你需要知道 <em>sub</em> 所在位置时使用。 要检查 <em>sub</em> 是否为子串，请使用 <a class="reference internal" href="expressions.html#in" tppabs="https://docs.python.org/zh-cn/3/reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 操作符:</p>
<div class="last highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Py&#39;</span> <span class="ow">in</span> <span class="sa">b</span><span class="s1">&#39;Python&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>也接受 0 至 255 范围内的整数作为子序列。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.index">
<code class="descclassname">bytes.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.index" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.index">
<code class="descclassname">bytearray.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.index" title="永久链接至目标">¶</a></dt>
<dd><p>类似于 <a class="reference internal" href="#bytes.find" title="bytes.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a>，但在找不到子序列时会引发 <a class="reference internal" href="exceptions.html#ValueError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>要搜索的子序列可以是任意 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 或是 0 至 255 范围内的整数。</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>也接受 0 至 255 范围内的整数作为子序列。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.join">
<code class="descclassname">bytes.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.join" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.join">
<code class="descclassname">bytearray.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.join" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个由 <em>iterable</em> 中的二进制数据序列拼接而成的 bytes 或 bytearray 对象。 如果 <em>iterable</em> 中存在任何非 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">字节类对象</span></a> 包括存在 <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 对象值则会引发 <a class="reference internal" href="exceptions.html#TypeError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 提供该方法的 bytes 或 bytearray 对象的内容将作为元素之间的分隔。</p>
</dd></dl>

<dl class="staticmethod">
<dt id="bytes.maketrans">
<em class="property">static </em><code class="descclassname">bytes.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>from</em>, <em>to</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.maketrans" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.maketrans">
<em class="property">static </em><code class="descclassname">bytearray.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>from</em>, <em>to</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.maketrans" title="永久链接至目标">¶</a></dt>
<dd><p>此静态方法返回一个可用于 <a class="reference internal" href="#bytes.translate" title="bytes.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.translate()</span></code></a> 的转换对照表，它将把 <em>from</em> 中的每个字符映射为 <em>to</em> 中相同位置上的字符；<em>from</em> 与 <em>to</em> 必须都是 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">字节类对象</span></a> 并且具有相同的长度。</p>
<div class="versionadded">
<p><span class="versionmodified">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.partition">
<code class="descclassname">bytes.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.partition" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.partition">
<code class="descclassname">bytearray.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.partition" title="永久链接至目标">¶</a></dt>
<dd><p>在 <em>sep</em> 首次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身或其 bytearray 副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含原序列以及两个空的 bytes 或 bytearray 对象。</p>
<p>要搜索的分隔符可以是任意 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。</p>
</dd></dl>

<dl class="method">
<dt id="bytes.replace">
<code class="descclassname">bytes.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.replace" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.replace">
<code class="descclassname">bytearray.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.replace" title="永久链接至目标">¶</a></dt>
<dd><p>返回序列的副本，其中出现的所有子序列 <em>old</em> 都将被替换为 <em>new</em>。 如果给出了可选参数 <em>count</em>，则只替换前 <em>count</em> 次出现。</p>
<p>要搜索的子序列及其替换序列可以是任意 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rfind">
<code class="descclassname">bytes.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rfind" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.rfind">
<code class="descclassname">bytearray.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rfind" title="永久链接至目标">¶</a></dt>
<dd><p>返回子序列 <em>sub</em> 在序列内被找到的最大（最右）索引，这样 <em>sub</em> 将包含在 <code class="docutils literal notranslate"><span class="pre">s[start:end]</span></code> 当中。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果未找到则返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p>
<p>要搜索的子序列可以是任意 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 或是 0 至 255 范围内的整数。</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>也接受 0 至 255 范围内的整数作为子序列。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rindex">
<code class="descclassname">bytes.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rindex" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.rindex">
<code class="descclassname">bytearray.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rindex" title="永久链接至目标">¶</a></dt>
<dd><p>类似于 <a class="reference internal" href="#bytes.rfind" title="bytes.rfind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rfind()</span></code></a>，但在子序列 <em>sub</em> 未找到时会引发 <a class="reference internal" href="exceptions.html#ValueError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>要搜索的子序列可以是任意 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 或是 0 至 255 范围内的整数。</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>也接受 0 至 255 范围内的整数作为子序列。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rpartition">
<code class="descclassname">bytes.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rpartition" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.rpartition">
<code class="descclassname">bytearray.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rpartition" title="永久链接至目标">¶</a></dt>
<dd><p>在 <em>sep</em> 最后一次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分，分隔符本身或其 bytearray 副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空的 bytes 或 bytearray 对象以及原序列的副本。</p>
<p>要搜索的分隔符可以是任意 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。</p>
</dd></dl>

<dl class="method">
<dt id="bytes.startswith">
<code class="descclassname">bytes.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.startswith" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.startswith">
<code class="descclassname">bytearray.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.startswith" title="永久链接至目标">¶</a></dt>
<dd><p>如果二进制数据以指定的 <em>prefix</em> 开头则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 <em>prefix</em> 也可以为由多个供查找的前缀构成的元组。 如果有可选项 <em>start</em>，将从所指定位置开始检查。 如果有可选项 <em>end</em>，将在所指定位置停止比较。</p>
<p>要搜索的前缀可以是任意 <a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。</p>
</dd></dl>

<dl class="method">
<dt id="bytes.translate">
<code class="descclassname">bytes.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em>, <em>delete=b''</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.translate" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.translate">
<code class="descclassname">bytearray.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em>, <em>delete=b''</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.translate" title="永久链接至目标">¶</a></dt>
<dd><p>返回原 bytes 或 bytearray 对象的副本，移除其中所有在可选参数 <em>delete</em> 中出现的 bytes，其余 bytes 将通过给定的转换表进行映射，该转换表必须是长度为 256 的 bytes 对象。</p>
<p>你可以使用 <a class="reference internal" href="#bytes.maketrans" title="bytes.maketrans"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.maketrans()</span></code></a> 方法来创建转换表。</p>
<p>对于仅需移除字符的转换，请将 <em>table</em> 参数设为 <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;read this short text&#39;</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;aeiou&#39;</span><span class="p">)</span>
<span class="go">b&#39;rd ths shrt txt&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.6 版更改: </span>现在支持将 <em>delete</em> 作为关键字参数。</p>
</div>
</dd></dl>

<p>The following methods on bytes and bytearray objects have default behaviours
that assume the use of ASCII compatible binary formats, but can still be used
with arbitrary binary data by passing appropriate arguments. Note that all of
the bytearray methods in this section do <em>not</em> operate in place, and instead
produce new objects.</p>
<dl class="method">
<dt id="bytes.center">
<code class="descclassname">bytes.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.center" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.center">
<code class="descclassname">bytearray.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.center" title="永久链接至目标">¶</a></dt>
<dd><p>Return a copy of the object centered in a sequence of length <em>width</em>.
Padding is done using the specified <em>fillbyte</em> (default is an ASCII
space). For <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> objects, the original sequence is returned if
<em>width</em> is less than or equal to <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.ljust">
<code class="descclassname">bytes.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.ljust" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.ljust">
<code class="descclassname">bytearray.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.ljust" title="永久链接至目标">¶</a></dt>
<dd><p>Return a copy of the object left justified in a sequence of length <em>width</em>.
Padding is done using the specified <em>fillbyte</em> (default is an ASCII
space). For <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> objects, the original sequence is returned if
<em>width</em> is less than or equal to <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.lstrip">
<code class="descclassname">bytes.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.lstrip" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.lstrip">
<code class="descclassname">bytearray.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.lstrip" title="永久链接至目标">¶</a></dt>
<dd><p>Return a copy of the sequence with specified leading bytes removed.  The
<em>chars</em> argument is a binary sequence specifying the set of byte values to
be removed - the name refers to the fact this method is usually used with
ASCII characters.  If omitted or <code class="docutils literal notranslate"><span class="pre">None</span></code>, the <em>chars</em> argument defaults
to removing ASCII whitespace.  The <em>chars</em> argument is not a prefix;
rather, all combinations of its values are stripped:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">b&#39;spacious   &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">b&#39;example.com&#39;</span>
</pre></div>
</div>
<p>The binary sequence of byte values to remove may be any
<a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rjust">
<code class="descclassname">bytes.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rjust" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.rjust">
<code class="descclassname">bytearray.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rjust" title="永久链接至目标">¶</a></dt>
<dd><p>Return a copy of the object right justified in a sequence of length <em>width</em>.
Padding is done using the specified <em>fillbyte</em> (default is an ASCII
space). For <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> objects, the original sequence is returned if
<em>width</em> is less than or equal to <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rsplit">
<code class="descclassname">bytes.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rsplit" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.rsplit">
<code class="descclassname">bytearray.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rsplit" title="永久链接至目标">¶</a></dt>
<dd><p>Split the binary sequence into subsequences of the same type, using <em>sep</em>
as the delimiter string. If <em>maxsplit</em> is given, at most <em>maxsplit</em> splits
are done, the <em>rightmost</em> ones.  If <em>sep</em> is not specified or <code class="docutils literal notranslate"><span class="pre">None</span></code>,
any subsequence consisting solely of ASCII whitespace is a separator.
Except for splitting from the right, <a class="reference internal" href="#bytearray.rsplit" title="bytearray.rsplit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rsplit()</span></code></a> behaves like
<a class="reference internal" href="#bytearray.split" title="bytearray.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> which is described in detail below.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.rstrip">
<code class="descclassname">bytes.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rstrip" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.rstrip">
<code class="descclassname">bytearray.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rstrip" title="永久链接至目标">¶</a></dt>
<dd><p>Return a copy of the sequence with specified trailing bytes removed.  The
<em>chars</em> argument is a binary sequence specifying the set of byte values to
be removed - the name refers to the fact this method is usually used with
ASCII characters.  If omitted or <code class="docutils literal notranslate"><span class="pre">None</span></code>, the <em>chars</em> argument defaults to
removing ASCII whitespace.  The <em>chars</em> argument is not a suffix; rather,
all combinations of its values are stripped:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">b&#39;   spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;mississippi&#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ipz&#39;</span><span class="p">)</span>
<span class="go">b&#39;mississ&#39;</span>
</pre></div>
</div>
<p>The binary sequence of byte values to remove may be any
<a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.split">
<code class="descclassname">bytes.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.split" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.split">
<code class="descclassname">bytearray.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.split" title="永久链接至目标">¶</a></dt>
<dd><p>Split the binary sequence into subsequences of the same type, using <em>sep</em>
as the delimiter string. If <em>maxsplit</em> is given and non-negative, at most
<em>maxsplit</em> splits are done (thus, the list will have at most <code class="docutils literal notranslate"><span class="pre">maxsplit+1</span></code>
elements).  If <em>maxsplit</em> is not specified or is <code class="docutils literal notranslate"><span class="pre">-1</span></code>, then there is no
limit on the number of splits (all possible splits are made).</p>
<p>If <em>sep</em> is given, consecutive delimiters are not grouped together and are
deemed to delimit empty subsequences (for example, <code class="docutils literal notranslate"><span class="pre">b'1,,2'.split(b',')</span></code>
returns <code class="docutils literal notranslate"><span class="pre">[b'1',</span> <span class="pre">b'',</span> <span class="pre">b'2']</span></code>).  The <em>sep</em> argument may consist of a
multibyte sequence (for example, <code class="docutils literal notranslate"><span class="pre">b'1&lt;&gt;2&lt;&gt;3'.split(b'&lt;&gt;')</span></code> returns
<code class="docutils literal notranslate"><span class="pre">[b'1',</span> <span class="pre">b'2',</span> <span class="pre">b'3']</span></code>). Splitting an empty sequence with a specified
separator returns <code class="docutils literal notranslate"><span class="pre">[b'']</span></code> or <code class="docutils literal notranslate"><span class="pre">[bytearray(b'')]</span></code> depending on the type
of object being split.  The <em>sep</em> argument may be any
<a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>.</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2,3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,,3,&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;&#39;, b&#39;3&#39;, b&#39;&#39;]</span>
</pre></div>
</div>
<p>If <em>sep</em> is not specified or is <code class="docutils literal notranslate"><span class="pre">None</span></code>, a different splitting algorithm
is applied: runs of consecutive ASCII whitespace are regarded as a single
separator, and the result will contain no empty strings at the start or
end if the sequence has leading or trailing whitespace.  Consequently,
splitting an empty sequence or a sequence consisting solely of ASCII
whitespace without a specified separator returns <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2 3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   1   2   3   &#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.strip">
<code class="descclassname">bytes.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.strip" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.strip">
<code class="descclassname">bytearray.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.strip" title="永久链接至目标">¶</a></dt>
<dd><p>Return a copy of the sequence with specified leading and trailing bytes
removed. The <em>chars</em> argument is a binary sequence specifying the set of
byte values to be removed - the name refers to the fact this method is
usually used with ASCII characters.  If omitted or <code class="docutils literal notranslate"><span class="pre">None</span></code>, the <em>chars</em>
argument defaults to removing ASCII whitespace. The <em>chars</em> argument is
not a prefix or suffix; rather, all combinations of its values are
stripped:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">b&#39;spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">b&#39;example&#39;</span>
</pre></div>
</div>
<p>The binary sequence of byte values to remove may be any
<a class="reference internal" href="glossary.html#term-bytes-like-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
</dd></dl>

<p>The following methods on bytes and bytearray objects assume the use of ASCII
compatible binary formats and should not be applied to arbitrary binary data.
Note that all of the bytearray methods in this section do <em>not</em> operate in
place, and instead produce new objects.</p>
<dl class="method">
<dt id="bytes.capitalize">
<code class="descclassname">bytes.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.capitalize" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.capitalize">
<code class="descclassname">bytearray.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.capitalize" title="永久链接至目标">¶</a></dt>
<dd><p>Return a copy of the sequence with each byte interpreted as an ASCII
character, and the first byte capitalized and the rest lowercased.
Non-ASCII byte values are passed through unchanged.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.expandtabs">
<code class="descclassname">bytes.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.expandtabs" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.expandtabs">
<code class="descclassname">bytearray.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.expandtabs" title="永久链接至目标">¶</a></dt>
<dd><p>Return a copy of the sequence where all ASCII tab characters are replaced
by one or more ASCII spaces, depending on the current column and the given
tab size.  Tab positions occur every <em>tabsize</em> bytes (default is 8,
giving tab positions at columns 0, 8, 16 and so on).  To expand the
sequence, the current column is set to zero and the sequence is examined
byte by byte.  If the byte is an ASCII tab character (<code class="docutils literal notranslate"><span class="pre">b'\t'</span></code>), one or
more space characters are inserted in the result until the current column
is equal to the next tab position. (The tab character itself is not
copied.)  If the current byte is an ASCII newline (<code class="docutils literal notranslate"><span class="pre">b'\n'</span></code>) or
carriage return (<code class="docutils literal notranslate"><span class="pre">b'\r'</span></code>), it is copied and the current column is reset
to zero.  Any other byte value is copied unchanged and the current column
is incremented by one regardless of how the byte value is represented when
printed:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
<span class="go">b&#39;01      012     0123    01234&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">b&#39;01  012 0123    01234&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isalnum">
<code class="descclassname">bytes.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isalnum" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.isalnum">
<code class="descclassname">bytearray.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isalnum" title="永久链接至目标">¶</a></dt>
<dd><p>Return true if all bytes in the sequence are alphabetical ASCII characters
or ASCII decimal digits and the sequence is not empty, false otherwise.
Alphabetic ASCII characters are those byte values in the sequence
<code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>. ASCII decimal
digits are those byte values in the sequence <code class="docutils literal notranslate"><span class="pre">b'0123456789'</span></code>.</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc1&#39;</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABC abc1&#39;</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isalpha">
<code class="descclassname">bytes.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isalpha" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.isalpha">
<code class="descclassname">bytearray.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isalpha" title="永久链接至目标">¶</a></dt>
<dd><p>Return true if all bytes in the sequence are alphabetic ASCII characters
and the sequence is not empty, false otherwise.  Alphabetic ASCII
characters are those byte values in the sequence
<code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc&#39;</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc1&#39;</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isascii">
<code class="descclassname">bytes.</code><code class="descname">isascii</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isascii" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.isascii">
<code class="descclassname">bytearray.</code><code class="descname">isascii</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isascii" title="永久链接至目标">¶</a></dt>
<dd><p>Return true if the sequence is empty or all bytes in the sequence are ASCII,
false otherwise.
ASCII bytes are in the range 0-0x7F.</p>
<div class="versionadded">
<p><span class="versionmodified">3.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isdigit">
<code class="descclassname">bytes.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isdigit" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.isdigit">
<code class="descclassname">bytearray.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isdigit" title="永久链接至目标">¶</a></dt>
<dd><p>Return true if all bytes in the sequence are ASCII decimal digits
and the sequence is not empty, false otherwise. ASCII decimal digits are
those byte values in the sequence <code class="docutils literal notranslate"><span class="pre">b'0123456789'</span></code>.</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1234&#39;</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1.23&#39;</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.islower">
<code class="descclassname">bytes.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.islower" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.islower">
<code class="descclassname">bytearray.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.islower" title="永久链接至目标">¶</a></dt>
<dd><p>Return true if there is at least one lowercase ASCII character
in the sequence and no uppercase ASCII characters, false otherwise.</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;hello world&#39;</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Lowercase ASCII characters are those byte values in the sequence
<code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Uppercase ASCII characters
are those byte values in the sequence <code class="docutils literal notranslate"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.isspace">
<code class="descclassname">bytes.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isspace" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.isspace">
<code class="descclassname">bytearray.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isspace" title="永久链接至目标">¶</a></dt>
<dd><p>Return true if all bytes in the sequence are ASCII whitespace and the
sequence is not empty, false otherwise.  ASCII whitespace characters are
those byte values in the sequence <code class="docutils literal notranslate"><span class="pre">b'</span> <span class="pre">\t\n\r\x0b\f'</span></code> (space, tab, newline,
carriage return, vertical tab, form feed).</p>
</dd></dl>

<dl class="method">
<dt id="bytes.istitle">
<code class="descclassname">bytes.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.istitle" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.istitle">
<code class="descclassname">bytearray.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.istitle" title="永久链接至目标">¶</a></dt>
<dd><p>Return true if the sequence is ASCII titlecase and the sequence is not
empty, false otherwise. See <a class="reference internal" href="#bytes.title" title="bytes.title"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.title()</span></code></a> for more details on the
definition of &quot;titlecase&quot;.</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">istitle</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">istitle</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isupper">
<code class="descclassname">bytes.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isupper" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.isupper">
<code class="descclassname">bytearray.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isupper" title="永久链接至目标">¶</a></dt>
<dd><p>Return true if there is at least one uppercase alphabetic ASCII character
in the sequence and no lowercase ASCII characters, false otherwise.</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;HELLO WORLD&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Lowercase ASCII characters are those byte values in the sequence
<code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Uppercase ASCII characters
are those byte values in the sequence <code class="docutils literal notranslate"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.lower">
<code class="descclassname">bytes.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.lower" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.lower">
<code class="descclassname">bytearray.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.lower" title="永久链接至目标">¶</a></dt>
<dd><p>Return a copy of the sequence with all the uppercase ASCII characters
converted to their corresponding lowercase counterpart.</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="go">b&#39;hello world&#39;</span>
</pre></div>
</div>
<p>Lowercase ASCII characters are those byte values in the sequence
<code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Uppercase ASCII characters
are those byte values in the sequence <code class="docutils literal notranslate"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
</dd></dl>

<span class="target" id="index-42"></span><dl class="method">
<dt id="bytes.splitlines">
<code class="descclassname">bytes.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><em>keepends=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.splitlines" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.splitlines">
<code class="descclassname">bytearray.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><em>keepends=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.splitlines" title="永久链接至目标">¶</a></dt>
<dd><p>Return a list of the lines in the binary sequence, breaking at ASCII
line boundaries. This method uses the <a class="reference internal" href="glossary.html#term-universal-newlines" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> approach
to splitting lines. Line breaks are not included in the resulting list
unless <em>keepends</em> is given and true.</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[b&#39;ab c&#39;, b&#39;&#39;, b&#39;de fg&#39;, b&#39;kl&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[b&#39;ab c\n&#39;, b&#39;\n&#39;, b&#39;de fg\r&#39;, b&#39;kl\r\n&#39;]</span>
</pre></div>
</div>
<p>Unlike <a class="reference internal" href="#bytes.split" title="bytes.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> when a delimiter string <em>sep</em> is given, this
method returns an empty list for the empty string, and a terminal line
break does not result in an extra line:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">),</span> <span class="sa">b</span><span class="s2">&quot;Two lines</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">([b&#39;&#39;], [b&#39;Two lines&#39;, b&#39;&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">&quot;One line</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">([], [b&#39;One line&#39;])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.swapcase">
<code class="descclassname">bytes.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.swapcase" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.swapcase">
<code class="descclassname">bytearray.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.swapcase" title="永久链接至目标">¶</a></dt>
<dd><p>Return a copy of the sequence with all the lowercase ASCII characters
converted to their corresponding uppercase counterpart and vice-versa.</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">swapcase</span><span class="p">()</span>
<span class="go">b&#39;hELLO wORLD&#39;</span>
</pre></div>
</div>
<p>Lowercase ASCII characters are those byte values in the sequence
<code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Uppercase ASCII characters
are those byte values in the sequence <code class="docutils literal notranslate"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
<p>Unlike <a class="reference internal" href="#str.swapcase" title="str.swapcase"><code class="xref py py-func docutils literal notranslate"><span class="pre">str.swapcase()</span></code></a>, it is always the case that
<code class="docutils literal notranslate"><span class="pre">bin.swapcase().swapcase()</span> <span class="pre">==</span> <span class="pre">bin</span></code> for the binary versions. Case
conversions are symmetrical in ASCII, even though that is not generally
true for arbitrary Unicode code points.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.title">
<code class="descclassname">bytes.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.title" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.title">
<code class="descclassname">bytearray.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.title" title="永久链接至目标">¶</a></dt>
<dd><p>Return a titlecased version of the binary sequence where words start with
an uppercase ASCII character and the remaining characters are lowercase.
Uncased byte values are left unmodified.</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">b&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>Lowercase ASCII characters are those byte values in the sequence
<code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Uppercase ASCII characters
are those byte values in the sequence <code class="docutils literal notranslate"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.
All other byte values are uncased.</p>
<p>该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 该定义在多数情况下都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望的结果:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;they&#39;re bill&#39;s friends from the UK&quot;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">b&quot;They&#39;Re Bill&#39;S Friends From The Uk&quot;</span>
</pre></div>
</div>
<p>可以使用正则表达式来构建针对撇号的特别处理:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">titlecase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">rb</span><span class="s2">&quot;[A-Za-z]+(&#39;[A-Za-z]+)?&quot;</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="k">lambda</span> <span class="n">mo</span><span class="p">:</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span>
<span class="gp">... </span>                             <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
<span class="gp">... </span>                  <span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">titlecase</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;they&#39;re bill&#39;s friends.&quot;</span><span class="p">)</span>
<span class="go">b&quot;They&#39;re Bill&#39;s Friends.&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.upper">
<code class="descclassname">bytes.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.upper" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.upper">
<code class="descclassname">bytearray.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.upper" title="永久链接至目标">¶</a></dt>
<dd><p>Return a copy of the sequence with all the lowercase ASCII characters
converted to their corresponding uppercase counterpart.</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="go">b&#39;HELLO WORLD&#39;</span>
</pre></div>
</div>
<p>Lowercase ASCII characters are those byte values in the sequence
<code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Uppercase ASCII characters
are those byte values in the sequence <code class="docutils literal notranslate"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.zfill">
<code class="descclassname">bytes.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.zfill" title="永久链接至目标">¶</a></dt>
<dt id="bytearray.zfill">
<code class="descclassname">bytearray.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.zfill" title="永久链接至目标">¶</a></dt>
<dd><p>Return a copy of the sequence left filled with ASCII <code class="docutils literal notranslate"><span class="pre">b'0'</span></code> digits to
make a sequence of length <em>width</em>. A leading sign prefix (<code class="docutils literal notranslate"><span class="pre">b'+'</span></code>/
<code class="docutils literal notranslate"><span class="pre">b'-'</span></code>) is handled by inserting the padding <em>after</em> the sign character
rather than before. For <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> objects, the original sequence is
returned if <em>width</em> is less than or equal to <code class="docutils literal notranslate"><span class="pre">len(seq)</span></code>.</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">b&#39;00042&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;-42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">b&#39;-0042&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
</dd></dl>

</div>
<div class="section" id="printf-style-bytes-formatting">
<span id="bytes-formatting"></span><h3><code class="docutils literal notranslate"><span class="pre">printf</span></code>-style Bytes Formatting<a class="headerlink" href="#printf-style-bytes-formatting" title="永久链接至标题">¶</a></h3>
<div class="admonition note" id="index-43">
<p class="first admonition-title">注解</p>
<p class="last">The formatting operations described here exhibit a variety of quirks that
lead to a number of common errors (such as failing to display tuples and
dictionaries correctly).  If the value being printed may be a tuple or
dictionary, wrap it in a tuple.</p>
</div>
<p>Bytes objects (<code class="docutils literal notranslate"><span class="pre">bytes</span></code>/<code class="docutils literal notranslate"><span class="pre">bytearray</span></code>) have one unique built-in operation:
the <code class="docutils literal notranslate"><span class="pre">%</span></code> operator (modulo).
This is also known as the bytes <em>formatting</em> or <em>interpolation</em> operator.
Given <code class="docutils literal notranslate"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">values</span></code> (where <em>format</em> is a bytes object), <code class="docutils literal notranslate"><span class="pre">%</span></code> conversion
specifications in <em>format</em> are replaced with zero or more elements of <em>values</em>.
The effect is similar to using the <code class="xref c c-func docutils literal notranslate"><span class="pre">sprintf()</span></code> in the C language.</p>
<p>If <em>format</em> requires a single argument, <em>values</em> may be a single non-tuple
object. <a class="footnote-reference" href="#id16" id="id11">[5]</a>  Otherwise, <em>values</em> must be a tuple with exactly the number of
items specified by the format bytes object, or a single mapping object (for
example, a dictionary).</p>
<p id="index-44">转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">'%'</span></code> 字符，用于标记转换符的起始。</li>
<li>映射键（可选），由加圆括号的字符序列组成 (例如 <code class="docutils literal notranslate"><span class="pre">(somename)</span></code>)。</li>
<li>转换旗标（可选），用于影响某些转换类型的结果。</li>
<li>最小字段宽度（可选）。 如果指定为 <code class="docutils literal notranslate"><span class="pre">'*'</span></code> (星号)，则实际宽度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。</li>
<li>精度（可选），以在 <code class="docutils literal notranslate"><span class="pre">'.'</span></code> (点号) 之后加精度值的形式给出。 如果指定为 <code class="docutils literal notranslate"><span class="pre">'*'</span></code> (星号)，则实际精度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为精度之后的元素。</li>
<li>长度修饰符（可选）。</li>
<li>转换类型。</li>
</ol>
<p>When the right argument is a dictionary (or other mapping type), then the
formats in the bytes object <em>must</em> include a parenthesised mapping key into that
dictionary inserted immediately after the <code class="docutils literal notranslate"><span class="pre">'%'</span></code> character. The mapping key
selects the value to be formatted from the mapping.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="si">%(language)s</span><span class="s1"> has </span><span class="si">%(number)03d</span><span class="s1"> quote types.&#39;</span> <span class="o">%</span>
<span class="gp">... </span>      <span class="p">{</span><span class="sa">b</span><span class="s1">&#39;language&#39;</span><span class="p">:</span> <span class="sa">b</span><span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;number&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">b&#39;Python has 002 quote types.&#39;</span>
</pre></div>
</div>
<p>在此情况下格式中不能出现 <code class="docutils literal notranslate"><span class="pre">*</span></code> 标记符（因其需要一个序列类的参数列表）。</p>
<p>转换旗标为：</p>
<table border="1" class="docutils" id="index-45">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">标志</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'#'</span></code></td>
<td>值的转换将使用“替代形式”（具体定义见下文）。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'0'</span></code></td>
<td>转换将为数字值填充零字符。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'-'</span></code></td>
<td>转换值将靠左对齐（如果同时给出 <code class="docutils literal notranslate"><span class="pre">'0'</span></code> 转换，则会覆盖后者）。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">'</span></code></td>
<td>(空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'+'</span></code></td>
<td>符号字符 (<code class="docutils literal notranslate"><span class="pre">'+'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'-'</span></code>) 将显示于转换结果的开头（会覆盖 &quot;空格&quot; 旗标）。</td>
</tr>
</tbody>
</table>
<p>可以给出长度修饰符 (<code class="docutils literal notranslate"><span class="pre">h</span></code>, <code class="docutils literal notranslate"><span class="pre">l</span></code> 或 <code class="docutils literal notranslate"><span class="pre">L</span></code>)，但会被忽略，因为对 Python 来说没有必要 -- 所以 <code class="docutils literal notranslate"><span class="pre">%ld</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">%d</span></code>。</p>
<p>转换类型为：</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="74%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">转换符</th>
<th class="head">含义</th>
<th class="head">注释</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'d'</span></code></td>
<td>有符号十进制整数。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'i'</span></code></td>
<td>有符号十进制整数。</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'o'</span></code></td>
<td>有符号八进制数。</td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'u'</span></code></td>
<td>过时类型 -- 等价于 <code class="docutils literal notranslate"><span class="pre">'d'</span></code>。</td>
<td>(8)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'x'</span></code></td>
<td>有符号十六进制数（小写）。</td>
<td>(2)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'X'</span></code></td>
<td>有符号十六进制数（大写）。</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'e'</span></code></td>
<td>浮点指数格式（小写）。</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'E'</span></code></td>
<td>浮点指数格式（大写）。</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'f'</span></code></td>
<td>浮点十进制格式。</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'F'</span></code></td>
<td>浮点十进制格式。</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'g'</span></code></td>
<td>浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。</td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'G'</span></code></td>
<td>浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。</td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'c'</span></code></td>
<td>Single byte (accepts integer or single
byte objects).</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'b'</span></code></td>
<td>Bytes (any object that follows the
<a class="reference internal" href="buffer.html#bufferobjects" tppabs="https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects"><span class="std std-ref">buffer protocol</span></a> or has
<a class="reference internal" href="datamodel.html#object.__bytes__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__bytes__" title="object.__bytes__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bytes__()</span></code></a>).</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'s'</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">'s'</span></code> is an alias for <code class="docutils literal notranslate"><span class="pre">'b'</span></code> and should only
be used for Python2/3 code bases.</td>
<td>(6)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'a'</span></code></td>
<td>Bytes (converts any Python object using
<code class="docutils literal notranslate"><span class="pre">repr(obj).encode('ascii','backslashreplace)</span></code>).</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'r'</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">'r'</span></code> is an alias for <code class="docutils literal notranslate"><span class="pre">'a'</span></code> and should only
be used for Python2/3 code bases.</td>
<td>(7)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'%'</span></code></td>
<td>不转换参数，在结果中输出一个 <code class="docutils literal notranslate"><span class="pre">'%'</span></code> 字符。</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>注释:</p>
<ol class="arabic">
<li><p class="first">此替代形式会在第一个数码之前插入标示八进制数的前缀 (<code class="docutils literal notranslate"><span class="pre">'0o'</span></code>)。</p>
</li>
<li><p class="first">此替代形式会在第一个数码之前插入 <code class="docutils literal notranslate"><span class="pre">'0x'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'0X'</span></code> 前缀（取决于是使用 <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 还是 <code class="docutils literal notranslate"><span class="pre">'X'</span></code> 格式）。</p>
</li>
<li><p class="first">此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。</p>
<p>小数点后的数码位数由精度决定，默认为 6。</p>
</li>
<li><p class="first">此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。</p>
<p>小数点前后的有效数码位数由精度决定，默认为 6。</p>
</li>
<li><p class="first">如果精度为 <code class="docutils literal notranslate"><span class="pre">N</span></code>，输出将截短为 <code class="docutils literal notranslate"><span class="pre">N</span></code> 个字符。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">b'%s'</span></code> is deprecated, but will not be removed during the 3.x series.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">b'%r'</span></code> is deprecated, but will not be removed during the 3.x series.</p>
</li>
<li><p class="first">参见 <span class="target" id="index-63"></span><a class="pep reference external" href="javascript:if(confirm('https://www.python.org/dev/peps/pep-0237  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://www.python.org/dev/peps/pep-0237'" tppabs="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a>。</p>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<p class="last"><span class="target" id="index-47"></span><a class="pep reference external" href="javascript:if(confirm('https://www.python.org/dev/peps/pep-0461  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://www.python.org/dev/peps/pep-0461'" tppabs="https://www.python.org/dev/peps/pep-0461"><strong>PEP 461</strong></a> - Adding % formatting to bytes and bytearray</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.5 新版功能.</span></p>
</div>
</div>
<div class="section" id="memory-views">
<span id="typememoryview"></span><h3>Memory Views<a class="headerlink" href="#memory-views" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> objects allow Python code to access the internal data
of an object that supports the <a class="reference internal" href="buffer.html#bufferobjects" tppabs="https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects"><span class="std std-ref">buffer protocol</span></a> without
copying.</p>
<dl class="class">
<dt id="memoryview">
<em class="property">class </em><code class="descname">memoryview</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#memoryview" title="永久链接至目标">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> that references <em>obj</em>.  <em>obj</em> must support the
buffer protocol.  Built-in objects that support the buffer protocol include
<a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> and <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>.</p>
<p>A <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> has the notion of an <em>element</em>, which is the
atomic memory unit handled by the originating object <em>obj</em>.  For many
simple types such as <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> and <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, an element
is a single byte, but other types such as <a class="reference internal" href="array.html#array.array" tppabs="https://docs.python.org/zh-cn/3/library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a> may have
bigger elements.</p>
<p><code class="docutils literal notranslate"><span class="pre">len(view)</span></code> is equal to the length of <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-class docutils literal notranslate"><span class="pre">tolist</span></code></a>.
If <code class="docutils literal notranslate"><span class="pre">view.ndim</span> <span class="pre">=</span> <span class="pre">0</span></code>, the length is 1. If <code class="docutils literal notranslate"><span class="pre">view.ndim</span> <span class="pre">=</span> <span class="pre">1</span></code>, the length
is equal to the number of elements in the view. For higher dimensions,
the length is equal to the length of the nested list representation of
the view. The <a class="reference internal" href="#memoryview.itemsize" title="memoryview.itemsize"><code class="xref py py-class docutils literal notranslate"><span class="pre">itemsize</span></code></a> attribute will give you the
number of bytes in a single element.</p>
<p>A <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> supports slicing and indexing to expose its data.
One-dimensional slicing will result in a subview:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">98</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">103</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">&lt;memory at 0x7f3ddc9f4350&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
<span class="go">b&#39;bce&#39;</span>
</pre></div>
</div>
<p>If <a class="reference internal" href="#memoryview.format" title="memoryview.format"><code class="xref py py-class docutils literal notranslate"><span class="pre">format</span></code></a> is one of the native format specifiers
from the <a class="reference internal" href="struct.html#module-struct" tppabs="https://docs.python.org/zh-cn/3/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> module, indexing with an integer or a tuple of
integers is also supported and returns a single <em>element</em> with
the correct type.  One-dimensional memoryviews can be indexed
with an integer or a one-integer tuple.  Multi-dimensional memoryviews
can be indexed with tuples of exactly <em>ndim</em> integers where <em>ndim</em> is
the number of dimensions.  Zero-dimensional memoryviews can be indexed
with the empty tuple.</p>
<p>Here is an example with a non-byte format:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">11111111</span><span class="p">,</span> <span class="mi">22222222</span><span class="p">,</span> <span class="o">-</span><span class="mi">33333333</span><span class="p">,</span> <span class="mi">44444444</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-11111111</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">44444444</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[-11111111, -33333333]</span>
</pre></div>
</div>
<p>If the underlying object is writable, the memoryview supports
one-dimensional slice assignment. Resizing is not allowed:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">readonly</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;zbcefg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;123&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;z123fg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;spam&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">memoryview assignment: lvalue and rvalue have different structures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;spam&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;z1spam&#39;)</span>
</pre></div>
</div>
<p>One-dimensional memoryviews of hashable (read-only) types with formats
'B', 'b' or 'c' are also hashable. The hash is defined as
<code class="docutils literal notranslate"><span class="pre">hash(m)</span> <span class="pre">==</span> <span class="pre">hash(m.tobytes())</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ce&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>One-dimensional memoryviews can now be sliced.
One-dimensional memoryviews with formats 'B', 'b' or 'c' are now hashable.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.4 版更改: </span>memoryview is now registered automatically with
<a class="reference internal" href="collections.abc.html#collections.abc.Sequence" tppabs="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.5 版更改: </span>memoryviews can now be indexed with tuple of integers.</p>
</div>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> has several methods:</p>
<dl class="method">
<dt id="memoryview.__eq__">
<code class="descname">__eq__</code><span class="sig-paren">(</span><em>exporter</em><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.__eq__" title="永久链接至目标">¶</a></dt>
<dd><p>A memoryview and a <span class="target" id="index-48"></span><a class="pep reference external" href="javascript:if(confirm('https://www.python.org/dev/peps/pep-3118  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://www.python.org/dev/peps/pep-3118'" tppabs="https://www.python.org/dev/peps/pep-3118"><strong>PEP 3118</strong></a> exporter are equal if their shapes are
equivalent and if all corresponding values are equal when the operands'
respective format codes are interpreted using <a class="reference internal" href="struct.html#module-struct" tppabs="https://docs.python.org/zh-cn/3/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> syntax.</p>
<p>For the subset of <a class="reference internal" href="struct.html#module-struct" tppabs="https://docs.python.org/zh-cn/3/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> format strings currently supported by
<a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tolist()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">v</span></code> and <code class="docutils literal notranslate"><span class="pre">w</span></code> are equal if <code class="docutils literal notranslate"><span class="pre">v.tolist()</span> <span class="pre">==</span> <span class="pre">w.tolist()</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="o">==</span> <span class="n">y</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">==</span> <span class="n">c</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If either format string is not supported by the <a class="reference internal" href="struct.html#module-struct" tppabs="https://docs.python.org/zh-cn/3/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> module,
then the objects will always compare as unequal (even if the format
strings and buffer contents are identical):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">BigEndianStructure</span><span class="p">,</span> <span class="n">c_long</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">BEPoint</span><span class="p">(</span><span class="n">BigEndianStructure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_long</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_long</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">BEPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">point</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that, as with floating point numbers, <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">is</span> <span class="pre">w</span></code> does <em>not</em> imply
<code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">==</span> <span class="pre">w</span></code> for memoryview objects.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>Previous versions compared the raw memory disregarding the item format
and the logical array structure.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.tobytes">
<code class="descname">tobytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.tobytes" title="永久链接至目标">¶</a></dt>
<dd><p>Return the data in the buffer as a bytestring.  This is equivalent to
calling the <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> constructor on the memoryview.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">b&#39;abc&#39;</span>
</pre></div>
</div>
<p>For non-contiguous arrays the result is equal to the flattened list
representation with all elements converted to bytes. <a class="reference internal" href="#memoryview.tobytes" title="memoryview.tobytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tobytes()</span></code></a>
supports all format strings, including those that are not in
<a class="reference internal" href="struct.html#module-struct" tppabs="https://docs.python.org/zh-cn/3/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> module syntax.</p>
</dd></dl>

<dl class="method">
<dt id="memoryview.hex">
<code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.hex" title="永久链接至目标">¶</a></dt>
<dd><p>Return a string object containing two hexadecimal digits for each
byte in the buffer.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;616263&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.tolist">
<code class="descname">tolist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.tolist" title="永久链接至目标">¶</a></dt>
<dd><p>Return the data in the buffer as a list of elements.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[97, 98, 99]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[1.1, 2.2, 3.3]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span><a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tolist()</span></code></a> now supports all single character native formats in
<a class="reference internal" href="struct.html#module-struct" tppabs="https://docs.python.org/zh-cn/3/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> module syntax as well as multi-dimensional
representations.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.release" title="永久链接至目标">¶</a></dt>
<dd><p>Release the underlying buffer exposed by the memoryview object.  Many
objects take special actions when a view is held on them (for example,
a <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> would temporarily forbid resizing); therefore,
calling release() is handy to remove these restrictions (and free any
dangling resources) as soon as possible.</p>
<p>After this method has been called, any further operation on the view
raises a <a class="reference internal" href="exceptions.html#ValueError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a> (except <a class="reference internal" href="#memoryview.release" title="memoryview.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a> itself which can
be called multiple times):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operation forbidden on released memoryview object</span>
</pre></div>
</div>
<p>The context management protocol can be used for a similar effect,
using the <code class="docutils literal notranslate"><span class="pre">with</span></code> statement:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">97</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operation forbidden on released memoryview object</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.cast">
<code class="descname">cast</code><span class="sig-paren">(</span><em>format</em><span class="optional">[</span>, <em>shape</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.cast" title="永久链接至目标">¶</a></dt>
<dd><p>Cast a memoryview to a new format or shape. <em>shape</em> defaults to
<code class="docutils literal notranslate"><span class="pre">[byte_length//new_itemsize]</span></code>, which means that the result view
will be one-dimensional. The return value is a new memoryview, but
the buffer itself is not copied. Supported casts are 1D -&gt; C-<a class="reference internal" href="glossary.html#term-contiguous" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>
and C-contiguous -&gt; 1D.</p>
<p>The destination format is restricted to a single element native format in
<a class="reference internal" href="struct.html#module-struct" tppabs="https://docs.python.org/zh-cn/3/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> syntax. One of the formats must be a byte format
('B', 'b' or 'c'). The byte length of the result must be the same
as the original length.</p>
<p>Cast 1D/long to 1D/unsigned bytes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;l&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;B&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">24</span>
</pre></div>
</div>
<p>Cast 1D/unsigned bytes to 1D/char:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;zyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;a&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">memoryview: invalid value for format &quot;B&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">bytearray(b&#39;ayz&#39;)</span>
</pre></div>
</div>
<p>Cast 1D/bytes to 3D/ints to 1D/signed char:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;i&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
</pre></div>
</div>
<p>Cast 1D/unsigned char to 2D/unsigned long:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0, 1, 2], [3, 4, 5]]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.5 版更改: </span>The source format is no longer restricted when casting to a byte view.</p>
</div>
</dd></dl>

<p>There are also several readonly attributes available:</p>
<dl class="attribute">
<dt id="memoryview.obj">
<code class="descname">obj</code><a class="headerlink" href="#memoryview.obj" title="永久链接至目标">¶</a></dt>
<dd><p>The underlying object of the memoryview:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.nbytes">
<code class="descname">nbytes</code><a class="headerlink" href="#memoryview.nbytes" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">nbytes</span> <span class="pre">==</span> <span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">len(m.tobytes())</span></code>. This is
the amount of space in bytes that the array would use in a contiguous
representation. It is not necessarily equal to <code class="docutils literal notranslate"><span class="pre">len(m)</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">m</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">12</span>
</pre></div>
</div>
<p>Multi-dimensional arrays:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="mf">1.5</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">96</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.readonly">
<code class="descname">readonly</code><a class="headerlink" href="#memoryview.readonly" title="永久链接至目标">¶</a></dt>
<dd><p>A bool indicating whether the memory is read only.</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.format">
<code class="descname">format</code><a class="headerlink" href="#memoryview.format" title="永久链接至目标">¶</a></dt>
<dd><p>A string containing the format (in <a class="reference internal" href="struct.html#module-struct" tppabs="https://docs.python.org/zh-cn/3/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> module style) for each
element in the view. A memoryview can be created from exporters with
arbitrary format strings, but some methods (e.g. <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tolist()</span></code></a>) are
restricted to native single element formats.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>format <code class="docutils literal notranslate"><span class="pre">'B'</span></code> is now handled according to the struct module syntax.
This means that <code class="docutils literal notranslate"><span class="pre">memoryview(b'abc')[0]</span> <span class="pre">==</span> <span class="pre">b'abc'[0]</span> <span class="pre">==</span> <span class="pre">97</span></code>.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.itemsize">
<code class="descname">itemsize</code><a class="headerlink" href="#memoryview.itemsize" title="永久链接至目标">¶</a></dt>
<dd><p>The size in bytes of each element of the memoryview:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span><span class="o">,</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">32000</span><span class="p">,</span> <span class="mi">32001</span><span class="p">,</span> <span class="mi">32002</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">32000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#memoryview.ndim" title="永久链接至目标">¶</a></dt>
<dd><p>An integer indicating how many dimensions of a multi-dimensional array the
memory represents.</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.shape">
<code class="descname">shape</code><a class="headerlink" href="#memoryview.shape" title="永久链接至目标">¶</a></dt>
<dd><p>A tuple of integers the length of <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ndim</span></code></a> giving the shape of the
memory as an N-dimensional array.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>An empty tuple instead of <code class="docutils literal notranslate"><span class="pre">None</span></code> when ndim = 0.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.strides">
<code class="descname">strides</code><a class="headerlink" href="#memoryview.strides" title="永久链接至目标">¶</a></dt>
<dd><p>A tuple of integers the length of <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ndim</span></code></a> giving the size in bytes to
access each element for each dimension of the array.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>An empty tuple instead of <code class="docutils literal notranslate"><span class="pre">None</span></code> when ndim = 0.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.suboffsets">
<code class="descname">suboffsets</code><a class="headerlink" href="#memoryview.suboffsets" title="永久链接至目标">¶</a></dt>
<dd><p>Used internally for PIL-style arrays. The value is informational only.</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.c_contiguous">
<code class="descname">c_contiguous</code><a class="headerlink" href="#memoryview.c_contiguous" title="永久链接至目标">¶</a></dt>
<dd><p>A bool indicating whether the memory is C-<a class="reference internal" href="glossary.html#term-contiguous" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.f_contiguous">
<code class="descname">f_contiguous</code><a class="headerlink" href="#memoryview.f_contiguous" title="永久链接至目标">¶</a></dt>
<dd><p>A bool indicating whether the memory is Fortran <a class="reference internal" href="glossary.html#term-contiguous" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.contiguous">
<code class="descname">contiguous</code><a class="headerlink" href="#memoryview.contiguous" title="永久链接至目标">¶</a></dt>
<dd><p>A bool indicating whether the memory is <a class="reference internal" href="glossary.html#term-contiguous" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">3.3 新版功能.</span></p>
</div>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="set-types-set-frozenset">
<span id="types-set"></span><h2>集合类型 --- <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a><a class="headerlink" href="#set-types-set-frozenset" title="永久链接至标题">¶</a></h2>
<p id="index-49">A <em class="dfn">set</em> object is an unordered collection of distinct <a class="reference internal" href="glossary.html#term-hashable" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> objects.
Common uses include membership testing, removing duplicates from a sequence, and
computing mathematical operations such as intersection, union, difference, and
symmetric difference.
(For other containers see the built-in <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>,
and <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> classes, and the <a class="reference internal" href="collections.html#module-collections" tppabs="https://docs.python.org/zh-cn/3/library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> module.)</p>
<p>Like other collections, sets support <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">len(set)</span></code>, and <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span>
<span class="pre">set</span></code>.  Being an unordered collection, sets do not record element position or
order of insertion.  Accordingly, sets do not support indexing, slicing, or
other sequence-like behavior.</p>
<p>There are currently two built-in set types, <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> and <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>.
The <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> type is mutable --- the contents can be changed using methods
like <code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code>.  Since it is mutable, it has no
hash value and cannot be used as either a dictionary key or as an element of
another set.  The <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> type is immutable and <a class="reference internal" href="glossary.html#term-hashable" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> ---
its contents cannot be altered after it is created; it can therefore be used as
a dictionary key or as an element of another set.</p>
<p>Non-empty sets (not frozensets) can be created by placing a comma-separated list
of elements within braces, for example: <code class="docutils literal notranslate"><span class="pre">{'jack',</span> <span class="pre">'sjoerd'}</span></code>, in addition to the
<a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> constructor.</p>
<p>The constructors for both classes work the same:</p>
<dl class="class">
<dt id="set">
<em class="property">class </em><code class="descname">set</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#set" title="永久链接至目标">¶</a></dt>
<dt id="frozenset">
<em class="property">class </em><code class="descname">frozenset</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset" title="永久链接至目标">¶</a></dt>
<dd><p>Return a new set or frozenset object whose elements are taken from
<em>iterable</em>.  The elements of a set must be <a class="reference internal" href="glossary.html#term-hashable" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>.  To
represent sets of sets, the inner sets must be <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>
objects.  If <em>iterable</em> is not specified, a new empty set is
returned.</p>
<p>Instances of <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> and <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> provide the following
operations:</p>
<dl class="describe">
<dt>
<code class="descname">len(s)</code></dt>
<dd><p>Return the number of elements in set <em>s</em> (cardinality of <em>s</em>).</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x in s</code></dt>
<dd><p>Test <em>x</em> for membership in <em>s</em>.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x not in s</code></dt>
<dd><p>Test <em>x</em> for non-membership in <em>s</em>.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.isdisjoint">
<code class="descname">isdisjoint</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.isdisjoint" title="永久链接至目标">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the set has no elements in common with <em>other</em>.  Sets are
disjoint if and only if their intersection is the empty set.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.issubset">
<code class="descname">issubset</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.issubset" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">set &lt;= other</code></dt>
<dd><p>Test whether every element in the set is in <em>other</em>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set &lt; other</code></dt>
<dd><p>Test whether the set is a proper subset of <em>other</em>, that is,
<code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">&lt;=</span> <span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.issuperset">
<code class="descname">issuperset</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.issuperset" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">set &gt;= other</code></dt>
<dd><p>Test whether every element in <em>other</em> is in the set.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set &gt; other</code></dt>
<dd><p>Test whether the set is a proper superset of <em>other</em>, that is, <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">&gt;=</span>
<span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.union">
<code class="descname">union</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.union" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">set | other | ...</code></dt>
<dd><p>Return a new set with elements from the set and all others.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.intersection" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">set &amp; other &amp; ...</code></dt>
<dd><p>Return a new set with elements common to the set and all others.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.difference">
<code class="descname">difference</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.difference" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">set - other - ...</code></dt>
<dd><p>Return a new set with elements in the set that are not in the others.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.symmetric_difference">
<code class="descname">symmetric_difference</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.symmetric_difference" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">set ^ other</code></dt>
<dd><p>Return a new set with elements in either the set or <em>other</em> but not both.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.copy" title="永久链接至目标">¶</a></dt>
<dd><p>Return a shallow copy of the set.</p>
</dd></dl>

<p>Note, the non-operator versions of <a class="reference internal" href="#frozenset.union" title="frozenset.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code></a>, <a class="reference internal" href="#frozenset.intersection" title="frozenset.intersection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection()</span></code></a>,
<a class="reference internal" href="#frozenset.difference" title="frozenset.difference"><code class="xref py py-meth docutils literal notranslate"><span class="pre">difference()</span></code></a>, and <a class="reference internal" href="#frozenset.symmetric_difference" title="frozenset.symmetric_difference"><code class="xref py py-meth docutils literal notranslate"><span class="pre">symmetric_difference()</span></code></a>, <a class="reference internal" href="#frozenset.issubset" title="frozenset.issubset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">issubset()</span></code></a>, and
<a class="reference internal" href="#frozenset.issuperset" title="frozenset.issuperset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">issuperset()</span></code></a> methods will accept any iterable as an argument.  In
contrast, their operator based counterparts require their arguments to be
sets.  This precludes error-prone constructions like <code class="docutils literal notranslate"><span class="pre">set('abc')</span> <span class="pre">&amp;</span> <span class="pre">'cbs'</span></code>
in favor of the more readable <code class="docutils literal notranslate"><span class="pre">set('abc').intersection('cbs')</span></code>.</p>
<p>Both <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> and <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> support set to set comparisons. Two
sets are equal if and only if every element of each set is contained in the
other (each is a subset of the other). A set is less than another set if and
only if the first set is a proper subset of the second set (is a subset, but
is not equal). A set is greater than another set if and only if the first set
is a proper superset of the second set (is a superset, but is not equal).</p>
<p>Instances of <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> are compared to instances of <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>
based on their members.  For example, <code class="docutils literal notranslate"><span class="pre">set('abc')</span> <span class="pre">==</span> <span class="pre">frozenset('abc')</span></code>
returns <code class="docutils literal notranslate"><span class="pre">True</span></code> and so does <code class="docutils literal notranslate"><span class="pre">set('abc')</span> <span class="pre">in</span> <span class="pre">set([frozenset('abc')])</span></code>.</p>
<p>The subset and equality comparisons do not generalize to a total ordering
function.  For example, any two nonempty disjoint sets are not equal and are not
subsets of each other, so <em>all</em> of the following return <code class="docutils literal notranslate"><span class="pre">False</span></code>: <code class="docutils literal notranslate"><span class="pre">a&lt;b</span></code>,
<code class="docutils literal notranslate"><span class="pre">a==b</span></code>, or <code class="docutils literal notranslate"><span class="pre">a&gt;b</span></code>.</p>
<p>Since sets only define partial ordering (subset relationships), the output of
the <a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> method is undefined for lists of sets.</p>
<p>Set elements, like dictionary keys, must be <a class="reference internal" href="glossary.html#term-hashable" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>.</p>
<p>Binary operations that mix <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> instances with <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>
return the type of the first operand.  For example: <code class="docutils literal notranslate"><span class="pre">frozenset('ab')</span> <span class="pre">|</span>
<span class="pre">set('bc')</span></code> returns an instance of <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>.</p>
<p>The following table lists operations available for <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> that do not
apply to immutable instances of <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>:</p>
<dl class="method">
<dt id="frozenset.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.update" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">set |= other | ...</code></dt>
<dd><p>Update the set, adding elements from all others.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.intersection_update">
<code class="descname">intersection_update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.intersection_update" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">set &amp;= other &amp; ...</code></dt>
<dd><p>Update the set, keeping only elements found in it and all others.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.difference_update">
<code class="descname">difference_update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.difference_update" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">set -= other | ...</code></dt>
<dd><p>Update the set, removing elements found in others.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.symmetric_difference_update">
<code class="descname">symmetric_difference_update</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.symmetric_difference_update" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">set ^= other</code></dt>
<dd><p>Update the set, keeping only elements found in either set, but not in both.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.add" title="永久链接至目标">¶</a></dt>
<dd><p>Add element <em>elem</em> to the set.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.remove" title="永久链接至目标">¶</a></dt>
<dd><p>Remove element <em>elem</em> from the set.  Raises <a class="reference internal" href="exceptions.html#KeyError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> if <em>elem</em> is
not contained in the set.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.discard">
<code class="descname">discard</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.discard" title="永久链接至目标">¶</a></dt>
<dd><p>Remove element <em>elem</em> from the set if it is present.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.pop" title="永久链接至目标">¶</a></dt>
<dd><p>Remove and return an arbitrary element from the set.  Raises
<a class="reference internal" href="exceptions.html#KeyError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> if the set is empty.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.clear" title="永久链接至目标">¶</a></dt>
<dd><p>Remove all elements from the set.</p>
</dd></dl>

<p>Note, the non-operator versions of the <a class="reference internal" href="#frozenset.update" title="frozenset.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a>,
<a class="reference internal" href="#frozenset.intersection_update" title="frozenset.intersection_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection_update()</span></code></a>, <a class="reference internal" href="#frozenset.difference_update" title="frozenset.difference_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">difference_update()</span></code></a>, and
<a class="reference internal" href="#frozenset.symmetric_difference_update" title="frozenset.symmetric_difference_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">symmetric_difference_update()</span></code></a> methods will accept any iterable as an
argument.</p>
<p>Note, the <em>elem</em> argument to the <a class="reference internal" href="datamodel.html#object.__contains__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, <a class="reference internal" href="#frozenset.remove" title="frozenset.remove"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code></a>, and
<a class="reference internal" href="#frozenset.discard" title="frozenset.discard"><code class="xref py py-meth docutils literal notranslate"><span class="pre">discard()</span></code></a> methods may be a set.  To support searching for an equivalent
frozenset, a temporary one is created from <em>elem</em>.</p>
</dd></dl>

</div>
<div class="section" id="mapping-types-dict">
<span id="typesmapping"></span><h2>映射类型 --- <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a><a class="headerlink" href="#mapping-types-dict" title="永久链接至标题">¶</a></h2>
<p id="index-50">A <a class="reference internal" href="glossary.html#term-mapping" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a> object maps <a class="reference internal" href="glossary.html#term-hashable" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> values to arbitrary objects.
Mappings are mutable objects.  There is currently only one standard mapping
type, the <em class="dfn">dictionary</em>.  (For other containers see the built-in
<a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, and <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> classes, and the
<a class="reference internal" href="collections.html#module-collections" tppabs="https://docs.python.org/zh-cn/3/library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> module.)</p>
<p>A dictionary's keys are <em>almost</em> arbitrary values.  Values that are not
<a class="reference internal" href="glossary.html#term-hashable" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>, that is, values containing lists, dictionaries or other
mutable types (that are compared by value rather than by object identity) may
not be used as keys.  Numeric types used for keys obey the normal rules for
numeric comparison: if two numbers compare equal (such as <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">1.0</span></code>)
then they can be used interchangeably to index the same dictionary entry.  (Note
however, that since computers store floating-point numbers as approximations it
is usually unwise to use them as dictionary keys.)</p>
<p>Dictionaries can be created by placing a comma-separated list of <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">value</span></code>
pairs within braces, for example: <code class="docutils literal notranslate"><span class="pre">{'jack':</span> <span class="pre">4098,</span> <span class="pre">'sjoerd':</span> <span class="pre">4127}</span></code> or <code class="docutils literal notranslate"><span class="pre">{4098:</span>
<span class="pre">'jack',</span> <span class="pre">4127:</span> <span class="pre">'sjoerd'}</span></code>, or by the <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> constructor.</p>
<dl class="class">
<dt id="dict">
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>**kwarg</em><span class="sig-paren">)</span><a class="headerlink" href="#dict" title="永久链接至目标">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>mapping</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>iterable</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dd><p>Return a new dictionary initialized from an optional positional argument
and a possibly empty set of keyword arguments.</p>
<p>If no positional argument is given, an empty dictionary is created.
If a positional argument is given and it is a mapping object, a dictionary
is created with the same key-value pairs as the mapping object.  Otherwise,
the positional argument must be an <a class="reference internal" href="glossary.html#term-iterable" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> object.  Each item in
the iterable must itself be an iterable with exactly two objects.  The
first object of each item becomes a key in the new dictionary, and the
second object the corresponding value.  If a key occurs more than once, the
last value for that key becomes the corresponding value in the new
dictionary.</p>
<p>If keyword arguments are given, the keyword arguments and their values are
added to the dictionary created from the positional argument.  If a key
being added is already present, the value from the keyword argument
replaces the value from the positional argument.</p>
<p>To illustrate, the following examples all return a dictionary equal to
<code class="docutils literal notranslate"><span class="pre">{&quot;one&quot;:</span> <span class="pre">1,</span> <span class="pre">&quot;two&quot;:</span> <span class="pre">2,</span> <span class="pre">&quot;three&quot;:</span> <span class="pre">3}</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">one</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">three</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;three&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span> <span class="o">==</span> <span class="n">d</span> <span class="o">==</span> <span class="n">e</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Providing keyword arguments as in the first example only works for keys that
are valid Python identifiers.  Otherwise, any valid keys can be used.</p>
<p>These are the operations that dictionaries support (and therefore, custom
mapping types should support too):</p>
<dl class="describe">
<dt>
<code class="descname">len(d)</code></dt>
<dd><p>Return the number of items in the dictionary <em>d</em>.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">d[key]</code></dt>
<dd><p>Return the item of <em>d</em> with key <em>key</em>.  Raises a <a class="reference internal" href="exceptions.html#KeyError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> if <em>key</em> is
not in the map.</p>
<p id="index-51">If a subclass of dict defines a method <a class="reference internal" href="datamodel.html#object.__missing__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__missing__()</span></code></a> and <em>key</em>
is not present, the <code class="docutils literal notranslate"><span class="pre">d[key]</span></code> operation calls that method with the key <em>key</em>
as argument.  The <code class="docutils literal notranslate"><span class="pre">d[key]</span></code> operation then returns or raises whatever is
returned or raised by the <code class="docutils literal notranslate"><span class="pre">__missing__(key)</span></code> call.
No other operations or methods invoke <a class="reference internal" href="datamodel.html#object.__missing__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__missing__()</span></code></a>. If
<a class="reference internal" href="datamodel.html#object.__missing__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__missing__()</span></code></a> is not defined, <a class="reference internal" href="exceptions.html#KeyError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> is raised.
<a class="reference internal" href="datamodel.html#object.__missing__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__missing__()</span></code></a> must be a method; it cannot be an instance variable:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Counter</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The example above shows part of the implementation of
<a class="reference internal" href="collections.html#collections.Counter" tppabs="https://docs.python.org/zh-cn/3/library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>.  A different <code class="docutils literal notranslate"><span class="pre">__missing__</span></code> method is used
by <a class="reference internal" href="collections.html#collections.defaultdict" tppabs="https://docs.python.org/zh-cn/3/library/collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">d[key] = value</code></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">d[key]</span></code> to <em>value</em>.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">del d[key]</code></dt>
<dd><p>Remove <code class="docutils literal notranslate"><span class="pre">d[key]</span></code> from <em>d</em>.  Raises a <a class="reference internal" href="exceptions.html#KeyError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> if <em>key</em> is not in the
map.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">key in d</code></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>d</em> has a key <em>key</em>, else <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">key not in d</code></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">d</span></code>.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">iter(d)</code></dt>
<dd><p>Return an iterator over the keys of the dictionary.  This is a shortcut
for <code class="docutils literal notranslate"><span class="pre">iter(d.keys())</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.clear" title="永久链接至目标">¶</a></dt>
<dd><p>Remove all items from the dictionary.</p>
</dd></dl>

<dl class="method">
<dt id="dict.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.copy" title="永久链接至目标">¶</a></dt>
<dd><p>Return a shallow copy of the dictionary.</p>
</dd></dl>

<dl class="classmethod">
<dt id="dict.fromkeys">
<em class="property">classmethod </em><code class="descname">fromkeys</code><span class="sig-paren">(</span><em>iterable</em><span class="optional">[</span>, <em>value</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.fromkeys" title="永久链接至目标">¶</a></dt>
<dd><p>Create a new dictionary with keys from <em>iterable</em> and values set to <em>value</em>.</p>
<p><a class="reference internal" href="#dict.fromkeys" title="dict.fromkeys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fromkeys()</span></code></a> is a class method that returns a new dictionary. <em>value</em>
defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.get" title="永久链接至目标">¶</a></dt>
<dd><p>Return the value for <em>key</em> if <em>key</em> is in the dictionary, else <em>default</em>.
If <em>default</em> is not given, it defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>, so that this method
never raises a <a class="reference internal" href="exceptions.html#KeyError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.items">
<code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.items" title="永久链接至目标">¶</a></dt>
<dd><p>Return a new view of the dictionary's items (<code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> pairs).
See the <a class="reference internal" href="#dict-views"><span class="std std-ref">documentation of view objects</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.keys" title="永久链接至目标">¶</a></dt>
<dd><p>Return a new view of the dictionary's keys.  See the <a class="reference internal" href="#dict-views"><span class="std std-ref">documentation
of view objects</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.pop" title="永久链接至目标">¶</a></dt>
<dd><p>If <em>key</em> is in the dictionary, remove it and return its value, else return
<em>default</em>.  If <em>default</em> is not given and <em>key</em> is not in the dictionary,
a <a class="reference internal" href="exceptions.html#KeyError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> is raised.</p>
</dd></dl>

<dl class="method">
<dt id="dict.popitem">
<code class="descname">popitem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.popitem" title="永久链接至目标">¶</a></dt>
<dd><p>Remove and return a <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> pair from the dictionary.
Pairs are returned in <abbr title="last-in, first-out">LIFO</abbr> order.</p>
<p><a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code></a> is useful to destructively iterate over a dictionary, as
often used in set algorithms.  If the dictionary is empty, calling
<a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code></a> raises a <a class="reference internal" href="exceptions.html#KeyError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.7 版更改: </span>LIFO order is now guaranteed. In prior versions, <a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code></a> would
return an arbitrary key/value pair.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="dict.setdefault">
<code class="descname">setdefault</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.setdefault" title="永久链接至目标">¶</a></dt>
<dd><p>如果字典存在键 <em>key</em> ，返回它的值。如果不存在，插入值为 <em>default</em> 的键 <em>key</em> ，并返回 <em>default</em> 。 <em>default</em> 默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

<dl class="method">
<dt id="dict.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em>other</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.update" title="永久链接至目标">¶</a></dt>
<dd><p>Update the dictionary with the key/value pairs from <em>other</em>, overwriting
existing keys.  Return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p><a class="reference internal" href="#dict.update" title="dict.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> accepts either another dictionary object or an iterable of
key/value pairs (as tuples or other iterables of length two).  If keyword
arguments are specified, the dictionary is then updated with those
key/value pairs: <code class="docutils literal notranslate"><span class="pre">d.update(red=1,</span> <span class="pre">blue=2)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.values" title="永久链接至目标">¶</a></dt>
<dd><p>Return a new view of the dictionary's values.  See the
<a class="reference internal" href="#dict-views"><span class="std std-ref">documentation of view objects</span></a>.</p>
</dd></dl>

<p>Dictionaries compare equal if and only if they have the same <code class="docutils literal notranslate"><span class="pre">(key,</span>
<span class="pre">value)</span></code> pairs. Order comparisons ('&lt;', '&lt;=', '&gt;=', '&gt;') raise
<a class="reference internal" href="exceptions.html#TypeError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<p>Dictionaries preserve insertion order.  Note that updating a key does not
affect the order.  Keys added after deletion are inserted at the end.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;one&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;two&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;three&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;four&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3, &#39;four&#39;: 4}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">[&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;one&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{&#39;one&#39;: 42, &#39;two&#39;: 2, &#39;three&#39;: 3, &#39;four&#39;: 4}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;two&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;two&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{&#39;one&#39;: 42, &#39;three&#39;: 3, &#39;four&#39;: 4, &#39;two&#39;: None}</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.7 版更改: </span>Dictionary order is guaranteed to be insertion order.  This behavior was
an implementation detail of CPython from 3.6.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<p class="last"><a class="reference internal" href="types.html#types.MappingProxyType" tppabs="https://docs.python.org/zh-cn/3/library/types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.MappingProxyType</span></code></a> can be used to create a read-only view
of a <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.</p>
</div>
<div class="section" id="dictionary-view-objects">
<span id="dict-views"></span><h3>Dictionary view objects<a class="headerlink" href="#dictionary-view-objects" title="永久链接至标题">¶</a></h3>
<p>The objects returned by <a class="reference internal" href="#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a> and
<a class="reference internal" href="#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a> are <em>view objects</em>.  They provide a dynamic view on the
dictionary's entries, which means that when the dictionary changes, the view
reflects these changes.</p>
<p>Dictionary views can be iterated over to yield their respective data, and
support membership tests:</p>
<dl class="describe">
<dt>
<code class="descname">len(dictview)</code></dt>
<dd><p>Return the number of entries in the dictionary.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">iter(dictview)</code></dt>
<dd><p>Return an iterator over the keys, values or items (represented as tuples of
<code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code>) in the dictionary.</p>
<p>Keys and values are iterated over in insertion order.
This allows the creation of <code class="docutils literal notranslate"><span class="pre">(value,</span> <span class="pre">key)</span></code> pairs
using <a class="reference internal" href="functions.html#zip" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">zip(d.values(),</span> <span class="pre">d.keys())</span></code>.  Another way to
create the same list is <code class="docutils literal notranslate"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">[(v,</span> <span class="pre">k)</span> <span class="pre">for</span> <span class="pre">(k,</span> <span class="pre">v)</span> <span class="pre">in</span> <span class="pre">d.items()]</span></code>.</p>
<p>Iterating views while adding or deleting entries in the dictionary may raise
a <a class="reference internal" href="exceptions.html#RuntimeError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> or fail to iterate over all entries.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.7 版更改: </span>Dictionary order is guaranteed to be insertion order.</p>
</div>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x in dictview</code></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>x</em> is in the underlying dictionary's keys, values or
items (in the latter case, <em>x</em> should be a <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> tuple).</p>
</dd></dl>

<p>Keys views are set-like since their entries are unique and hashable.  If all
values are hashable, so that <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> pairs are unique and hashable,
then the items view is also set-like.  (Values views are not treated as set-like
since the entries are generally not unique.)  For set-like views, all of the
operations defined for the abstract base class <a class="reference internal" href="collections.abc.html#collections.abc.Set" tppabs="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a> are
available (for example, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, or <code class="docutils literal notranslate"><span class="pre">^</span></code>).</p>
<p>An example of dictionary view usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dishes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;sausage&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># iteration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">+=</span> <span class="n">val</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">504</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># keys and values are iterated over in the same order (insertion order)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">[&#39;eggs&#39;, &#39;sausage&#39;, &#39;bacon&#39;, &#39;spam&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">[2, 1, 1, 500]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view objects are dynamic and reflect dict changes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s1">&#39;eggs&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s1">&#39;sausage&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">[&#39;bacon&#39;, &#39;spam&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># set operations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s1">&#39;eggs&#39;</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">,</span> <span class="s1">&#39;salad&#39;</span><span class="p">}</span>
<span class="go">{&#39;bacon&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">^</span> <span class="p">{</span><span class="s1">&#39;sausage&#39;</span><span class="p">,</span> <span class="s1">&#39;juice&#39;</span><span class="p">}</span>
<span class="go">{&#39;juice&#39;, &#39;sausage&#39;, &#39;bacon&#39;, &#39;spam&#39;}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="context-manager-types">
<span id="typecontextmanager"></span><h2>Context Manager Types<a class="headerlink" href="#context-manager-types" title="永久链接至标题">¶</a></h2>
<p id="index-52">Python's <a class="reference internal" href="compound_stmts.html#with" tppabs="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement supports the concept of a runtime context
defined by a context manager.  This is implemented using a pair of methods
that allow user-defined classes to define a runtime context that is entered
before the statement body is executed and exited when the statement ends:</p>
<dl class="method">
<dt id="contextmanager.__enter__">
<code class="descclassname">contextmanager.</code><code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#contextmanager.__enter__" title="永久链接至目标">¶</a></dt>
<dd><p>Enter the runtime context and return either this object or another object
related to the runtime context. The value returned by this method is bound to
the identifier in the <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> clause of <a class="reference internal" href="compound_stmts.html#with" tppabs="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statements using
this context manager.</p>
<p>An example of a context manager that returns itself is a <a class="reference internal" href="glossary.html#term-file-object" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>.
File objects return themselves from __enter__() to allow <a class="reference internal" href="functions.html#open" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> to be
used as the context expression in a <a class="reference internal" href="compound_stmts.html#with" tppabs="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement.</p>
<p>An example of a context manager that returns a related object is the one
returned by <a class="reference internal" href="decimal.html#decimal.localcontext" tppabs="https://docs.python.org/zh-cn/3/library/decimal.html#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">decimal.localcontext()</span></code></a>. These managers set the active
decimal context to a copy of the original decimal context and then return the
copy. This allows changes to be made to the current decimal context in the body
of the <a class="reference internal" href="compound_stmts.html#with" tppabs="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement without affecting code outside the
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> statement.</p>
</dd></dl>

<dl class="method">
<dt id="contextmanager.__exit__">
<code class="descclassname">contextmanager.</code><code class="descname">__exit__</code><span class="sig-paren">(</span><em>exc_type</em>, <em>exc_val</em>, <em>exc_tb</em><span class="sig-paren">)</span><a class="headerlink" href="#contextmanager.__exit__" title="永久链接至目标">¶</a></dt>
<dd><p>Exit the runtime context and return a Boolean flag indicating if any exception
that occurred should be suppressed. If an exception occurred while executing the
body of the <a class="reference internal" href="compound_stmts.html#with" tppabs="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement, the arguments contain the exception type,
value and traceback information. Otherwise, all three arguments are <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Returning a true value from this method will cause the <a class="reference internal" href="compound_stmts.html#with" tppabs="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement
to suppress the exception and continue execution with the statement immediately
following the <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> statement. Otherwise the exception continues
propagating after this method has finished executing. Exceptions that occur
during execution of this method will replace any exception that occurred in the
body of the <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> statement.</p>
<p>The exception passed in should never be reraised explicitly - instead, this
method should return a false value to indicate that the method completed
successfully and does not want to suppress the raised exception. This allows
context management code to easily detect whether or not an <a class="reference internal" href="#contextmanager.__exit__" title="contextmanager.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a>
method has actually failed.</p>
</dd></dl>

<p>Python defines several context managers to support easy thread synchronisation,
prompt closure of files or other objects, and simpler manipulation of the active
decimal arithmetic context. The specific types are not treated specially beyond
their implementation of the context management protocol. See the
<a class="reference internal" href="contextlib.html#module-contextlib" tppabs="https://docs.python.org/zh-cn/3/library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> module for some examples.</p>
<p>Python's <a class="reference internal" href="glossary.html#term-generator" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-generator"><span class="xref std std-term">generator</span></a>s and the <a class="reference internal" href="contextlib.html#contextlib.contextmanager" tppabs="https://docs.python.org/zh-cn/3/library/contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.contextmanager</span></code></a> decorator
provide a convenient way to implement these protocols.  If a generator function is
decorated with the <a class="reference internal" href="contextlib.html#contextlib.contextmanager" tppabs="https://docs.python.org/zh-cn/3/library/contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.contextmanager</span></code></a> decorator, it will return a
context manager implementing the necessary <a class="reference internal" href="datamodel.html#object.__enter__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> and
<a class="reference internal" href="datamodel.html#object.__exit__" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> methods, rather than the iterator produced by an undecorated
generator function.</p>
<p>Note that there is no specific slot for any of these methods in the type
structure for Python objects in the Python/C API. Extension types wanting to
define these methods must provide them as a normal Python accessible method.
Compared to the overhead of setting up the runtime context, the overhead of a
single class dictionary lookup is negligible.</p>
</div>
<div class="section" id="other-built-in-types">
<span id="typesother"></span><h2>Other Built-in Types<a class="headerlink" href="#other-built-in-types" title="永久链接至标题">¶</a></h2>
<p>The interpreter supports several other kinds of objects. Most of these support
only one or two operations.</p>
<div class="section" id="modules">
<span id="typesmodules"></span><h3>模块<a class="headerlink" href="#modules" title="永久链接至标题">¶</a></h3>
<p>The only special operation on a module is attribute access: <code class="docutils literal notranslate"><span class="pre">m.name</span></code>, where
<em>m</em> is a module and <em>name</em> accesses a name defined in <em>m</em>'s symbol table.
Module attributes can be assigned to.  (Note that the <a class="reference internal" href="simple_stmts.html#import" tppabs="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>
statement is not, strictly speaking, an operation on a module object; <code class="docutils literal notranslate"><span class="pre">import</span>
<span class="pre">foo</span></code> does not require a module object named <em>foo</em> to exist, rather it requires
an (external) <em>definition</em> for a module named <em>foo</em> somewhere.)</p>
<p>A special attribute of every module is <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>. This is the
dictionary containing the module's symbol table. Modifying this dictionary will
actually change the module's symbol table, but direct assignment to the
<a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> attribute is not possible (you can write
<code class="docutils literal notranslate"><span class="pre">m.__dict__['a']</span> <span class="pre">=</span> <span class="pre">1</span></code>, which defines <code class="docutils literal notranslate"><span class="pre">m.a</span></code> to be <code class="docutils literal notranslate"><span class="pre">1</span></code>, but you can't write
<code class="docutils literal notranslate"><span class="pre">m.__dict__</span> <span class="pre">=</span> <span class="pre">{}</span></code>).  Modifying <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> directly is
not recommended.</p>
<p>Modules built into the interpreter are written like this: <code class="docutils literal notranslate"><span class="pre">&lt;module</span> <span class="pre">'sys'</span>
<span class="pre">(built-in)&gt;</span></code>.  If loaded from a file, they are written as <code class="docutils literal notranslate"><span class="pre">&lt;module</span> <span class="pre">'os'</span> <span class="pre">from</span>
<span class="pre">'/usr/local/lib/pythonX.Y/os.pyc'&gt;</span></code>.</p>
</div>
<div class="section" id="classes-and-class-instances">
<span id="typesobjects"></span><h3>Classes and Class Instances<a class="headerlink" href="#classes-and-class-instances" title="永久链接至标题">¶</a></h3>
<p>See <a class="reference internal" href="datamodel.html#objects" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#objects"><span class="std std-ref">对象、值与类型</span></a> and <a class="reference internal" href="compound_stmts.html#class" tppabs="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#class"><span class="std std-ref">类定义</span></a> for these.</p>
</div>
<div class="section" id="functions">
<span id="typesfunctions"></span><h3>函数<a class="headerlink" href="#functions" title="永久链接至标题">¶</a></h3>
<p>Function objects are created by function definitions.  The only operation on a
function object is to call it: <code class="docutils literal notranslate"><span class="pre">func(argument-list)</span></code>.</p>
<p>There are really two flavors of function objects: built-in functions and
user-defined functions.  Both support the same operation (to call the function),
but the implementation is different, hence the different object types.</p>
<p>See <a class="reference internal" href="compound_stmts.html#function" tppabs="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#function"><span class="std std-ref">函数定义</span></a> for more information.</p>
</div>
<div class="section" id="methods">
<span id="typesmethods"></span><h3>方法<a class="headerlink" href="#methods" title="永久链接至标题">¶</a></h3>
<p id="index-53">Methods are functions that are called using the attribute notation. There are
two flavors: built-in methods (such as <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> on lists) and class
instance methods.  Built-in methods are described with the types that support
them.</p>
<p>If you access a method (a function defined in a class namespace) through an
instance, you get a special object: a <em class="dfn">bound method</em> (also called
<em class="dfn">instance method</em>) object. When called, it will add the <code class="docutils literal notranslate"><span class="pre">self</span></code> argument
to the argument list.  Bound methods have two special read-only attributes:
<code class="docutils literal notranslate"><span class="pre">m.__self__</span></code> is the object on which the method operates, and <code class="docutils literal notranslate"><span class="pre">m.__func__</span></code> is
the function implementing the method.  Calling <code class="docutils literal notranslate"><span class="pre">m(arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span> <span class="pre">arg-n)</span></code>
is completely equivalent to calling <code class="docutils literal notranslate"><span class="pre">m.__func__(m.__self__,</span> <span class="pre">arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span>
<span class="pre">arg-n)</span></code>.</p>
<p>Like function objects, bound method objects support getting arbitrary
attributes.  However, since method attributes are actually stored on the
underlying function object (<code class="docutils literal notranslate"><span class="pre">meth.__func__</span></code>), setting method attributes on
bound methods is disallowed.  Attempting to set an attribute on a method
results in an <a class="reference internal" href="exceptions.html#AttributeError" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> being raised.  In order to set a method
attribute, you need to explicitly set it on the underlying function object:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s1">&#39;my name is method&#39;</span>  <span class="c1"># can&#39;t set on the method</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;method&#39; object has no attribute &#39;whoami&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="vm">__func__</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s1">&#39;my name is method&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">whoami</span>
<span class="go">&#39;my name is method&#39;</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="datamodel.html#types" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#types"><span class="std std-ref">标准类型层级结构</span></a> for more information.</p>
</div>
<div class="section" id="code-objects">
<span id="bltin-code-objects"></span><span id="index-54"></span><h3>代码对象<a class="headerlink" href="#code-objects" title="永久链接至标题">¶</a></h3>
<p id="index-55">Code objects are used by the implementation to represent &quot;pseudo-compiled&quot;
executable Python code such as a function body. They differ from function
objects because they don't contain a reference to their global execution
environment.  Code objects are returned by the built-in <a class="reference internal" href="functions.html#compile" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> function
and can be extracted from function objects through their <code class="xref py py-attr docutils literal notranslate"><span class="pre">__code__</span></code>
attribute. See also the <a class="reference internal" href="code.html#module-code" tppabs="https://docs.python.org/zh-cn/3/library/code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal notranslate"><span class="pre">code</span></code></a> module.</p>
<p id="index-56">A code object can be executed or evaluated by passing it (instead of a source
string) to the <a class="reference internal" href="functions.html#exec" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> or <a class="reference internal" href="functions.html#eval" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>  built-in functions.</p>
<p>See <a class="reference internal" href="datamodel.html#types" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#types"><span class="std std-ref">标准类型层级结构</span></a> for more information.</p>
</div>
<div class="section" id="type-objects">
<span id="bltin-type-objects"></span><h3>Type 对象<a class="headerlink" href="#type-objects" title="永久链接至标题">¶</a></h3>
<p id="index-57">Type objects represent the various object types.  An object's type is accessed
by the built-in function <a class="reference internal" href="functions.html#type" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>.  There are no special operations on
types.  The standard module <a class="reference internal" href="types.html#module-types" tppabs="https://docs.python.org/zh-cn/3/library/types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">types</span></code></a> defines names for all standard built-in
types.</p>
<p>Types are written like this: <code class="docutils literal notranslate"><span class="pre">&lt;class</span> <span class="pre">'int'&gt;</span></code>.</p>
</div>
<div class="section" id="the-null-object">
<span id="bltin-null-object"></span><h3>The Null Object<a class="headerlink" href="#the-null-object" title="永久链接至标题">¶</a></h3>
<p>This object is returned by functions that don't explicitly return a value.  It
supports no special operations.  There is exactly one null object, named
<code class="docutils literal notranslate"><span class="pre">None</span></code> (a built-in name).  <code class="docutils literal notranslate"><span class="pre">type(None)()</span></code> produces the same singleton.</p>
<p>It is written as <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
<div class="section" id="the-ellipsis-object">
<span id="bltin-ellipsis-object"></span><span id="index-58"></span><h3>The Ellipsis Object<a class="headerlink" href="#the-ellipsis-object" title="永久链接至标题">¶</a></h3>
<p>This object is commonly used by slicing (see <a class="reference internal" href="expressions.html#slicings" tppabs="https://docs.python.org/zh-cn/3/reference/expressions.html#slicings"><span class="std std-ref">切片</span></a>).  It supports no
special operations.  There is exactly one ellipsis object, named
<a class="reference internal" href="constants.html#Ellipsis" tppabs="https://docs.python.org/zh-cn/3/library/constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal notranslate"><span class="pre">Ellipsis</span></code></a> (a built-in name).  <code class="docutils literal notranslate"><span class="pre">type(Ellipsis)()</span></code> produces the
<a class="reference internal" href="constants.html#Ellipsis" tppabs="https://docs.python.org/zh-cn/3/library/constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal notranslate"><span class="pre">Ellipsis</span></code></a> singleton.</p>
<p>It is written as <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> or <code class="docutils literal notranslate"><span class="pre">...</span></code>.</p>
</div>
<div class="section" id="the-notimplemented-object">
<span id="bltin-notimplemented-object"></span><h3>The NotImplemented Object<a class="headerlink" href="#the-notimplemented-object" title="永久链接至标题">¶</a></h3>
<p>This object is returned from comparisons and binary operations when they are
asked to operate on types they don't support. See <a class="reference internal" href="expressions.html#comparisons" tppabs="https://docs.python.org/zh-cn/3/reference/expressions.html#comparisons"><span class="std std-ref">比较运算</span></a> for more
information.  There is exactly one <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> object.
<code class="docutils literal notranslate"><span class="pre">type(NotImplemented)()</span></code> produces the singleton instance.</p>
<p>It is written as <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>.</p>
</div>
<div class="section" id="boolean-values">
<span id="bltin-boolean-values"></span><h3>布尔值<a class="headerlink" href="#boolean-values" title="永久链接至标题">¶</a></h3>
<p>Boolean values are the two constant objects <code class="docutils literal notranslate"><span class="pre">False</span></code> and <code class="docutils literal notranslate"><span class="pre">True</span></code>.  They are
used to represent truth values (although other values can also be considered
false or true).  In numeric contexts (for example when used as the argument to
an arithmetic operator), they behave like the integers 0 and 1, respectively.
The built-in function <a class="reference internal" href="functions.html#bool" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> can be used to convert any value to a
Boolean, if the value can be interpreted as a truth value (see section
<a class="reference internal" href="#truth"><span class="std std-ref">逻辑值检测</span></a> above).</p>
<p id="index-59">They are written as <code class="docutils literal notranslate"><span class="pre">False</span></code> and <code class="docutils literal notranslate"><span class="pre">True</span></code>, respectively.</p>
</div>
<div class="section" id="internal-objects">
<span id="typesinternal"></span><h3>Internal Objects<a class="headerlink" href="#internal-objects" title="永久链接至标题">¶</a></h3>
<p>See <a class="reference internal" href="datamodel.html#types" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#types"><span class="std std-ref">标准类型层级结构</span></a> for this information.  It describes stack frame objects,
traceback objects, and slice objects.</p>
</div>
</div>
<div class="section" id="special-attributes">
<span id="specialattrs"></span><h2>特殊属性<a class="headerlink" href="#special-attributes" title="永久链接至标题">¶</a></h2>
<p>The implementation adds a few special read-only attributes to several object
types, where they are relevant.  Some of these are not reported by the
<a class="reference internal" href="functions.html#dir" tppabs="https://docs.python.org/zh-cn/3/library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> built-in function.</p>
<dl class="attribute">
<dt id="object.__dict__">
<code class="descclassname">object.</code><code class="descname">__dict__</code><a class="headerlink" href="#object.__dict__" title="永久链接至目标">¶</a></dt>
<dd><p>A dictionary or other mapping object used to store an object's (writable)
attributes.</p>
</dd></dl>

<dl class="attribute">
<dt id="instance.__class__">
<code class="descclassname">instance.</code><code class="descname">__class__</code><a class="headerlink" href="#instance.__class__" title="永久链接至目标">¶</a></dt>
<dd><p>The class to which a class instance belongs.</p>
</dd></dl>

<dl class="attribute">
<dt id="class.__bases__">
<code class="descclassname">class.</code><code class="descname">__bases__</code><a class="headerlink" href="#class.__bases__" title="永久链接至目标">¶</a></dt>
<dd><p>The tuple of base classes of a class object.</p>
</dd></dl>

<dl class="attribute">
<dt id="definition.__name__">
<code class="descclassname">definition.</code><code class="descname">__name__</code><a class="headerlink" href="#definition.__name__" title="永久链接至目标">¶</a></dt>
<dd><p>The name of the class, function, method, descriptor, or
generator instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="definition.__qualname__">
<code class="descclassname">definition.</code><code class="descname">__qualname__</code><a class="headerlink" href="#definition.__qualname__" title="永久链接至目标">¶</a></dt>
<dd><p>The <a class="reference internal" href="glossary.html#term-qualified-name" tppabs="https://docs.python.org/zh-cn/3/glossary.html#term-qualified-name"><span class="xref std std-term">qualified name</span></a> of the class, function, method, descriptor,
or generator instance.</p>
<div class="versionadded">
<p><span class="versionmodified">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="class.__mro__">
<code class="descclassname">class.</code><code class="descname">__mro__</code><a class="headerlink" href="#class.__mro__" title="永久链接至目标">¶</a></dt>
<dd><p>This attribute is a tuple of classes that are considered when looking for
base classes during method resolution.</p>
</dd></dl>

<dl class="method">
<dt id="class.mro">
<code class="descclassname">class.</code><code class="descname">mro</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#class.mro" title="永久链接至目标">¶</a></dt>
<dd><p>This method can be overridden by a metaclass to customize the method
resolution order for its instances.  It is called at class instantiation, and
its result is stored in <a class="reference internal" href="#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__mro__</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="class.__subclasses__">
<code class="descclassname">class.</code><code class="descname">__subclasses__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasses__" title="永久链接至目标">¶</a></dt>
<dd><p>Each class keeps a list of weak references to its immediate subclasses.  This
method returns a list of all those references still alive.
Example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>
<span class="go">[&lt;class &#39;bool&#39;&gt;]</span>
</pre></div>
</div>
</dd></dl>

<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Additional information on these special methods may be found in the Python
Reference Manual (<a class="reference internal" href="datamodel.html#customization" tppabs="https://docs.python.org/zh-cn/3/reference/datamodel.html#customization"><span class="std std-ref">基本定制</span></a>).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>As a consequence, the list <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2]</span></code> is considered equal to <code class="docutils literal notranslate"><span class="pre">[1.0,</span> <span class="pre">2.0]</span></code>, and
similarly for tuples.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>They must have since the parser can't tell the type of the operands.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id7">2</a>, <a class="fn-backref" href="#id8">3</a>, <a class="fn-backref" href="#id9">4</a>)</em> Cased characters are those with general category property being one of
&quot;Lu&quot; (Letter, uppercase), &quot;Ll&quot; (Letter, lowercase), or &quot;Lt&quot; (Letter, titlecase).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id11">2</a>)</em> To format only a tuple you should therefore provide a singleton tuple whose only
element is the tuple to be formatted.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="contents.html" tppabs="https://docs.python.org/zh-cn/3/contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">内置类型</a><ul>
<li><a class="reference internal" href="#truth-value-testing">逻辑值检测</a></li>
<li><a class="reference internal" href="#boolean-operations-and-or-not">布尔运算 --- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code>, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code>, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a></li>
<li><a class="reference internal" href="#comparisons">比较</a></li>
<li><a class="reference internal" href="#numeric-types-int-float-complex">数字类型 --- <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">complex</span></code></a><ul>
<li><a class="reference internal" href="#bitwise-operations-on-integer-types">整数类型的按位运算</a></li>
<li><a class="reference internal" href="#additional-methods-on-integer-types">整数类型的附加方法</a></li>
<li><a class="reference internal" href="#additional-methods-on-float">浮点类型的附加方法</a></li>
<li><a class="reference internal" href="#hashing-of-numeric-types">数字类型的哈希运算</a></li>
</ul>
</li>
<li><a class="reference internal" href="#iterator-types">迭代器类型</a><ul>
<li><a class="reference internal" href="#generator-types">生成器类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequence-types-list-tuple-range">序列类型 --- <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">range</span></code></a><ul>
<li><a class="reference internal" href="#common-sequence-operations">通用序列操作</a></li>
<li><a class="reference internal" href="#immutable-sequence-types">不可变序列类型</a></li>
<li><a class="reference internal" href="#mutable-sequence-types">可变序列类型</a></li>
<li><a class="reference internal" href="#lists">列表</a></li>
<li><a class="reference internal" href="#tuples">元组</a></li>
<li><a class="reference internal" href="#ranges">range 对象</a></li>
</ul>
</li>
<li><a class="reference internal" href="#text-sequence-type-str">文本序列类型 --- <code class="docutils literal notranslate"><span class="pre">str</span></code></a><ul>
<li><a class="reference internal" href="#string-methods">字符串的方法</a></li>
<li><a class="reference internal" href="#printf-style-string-formatting"><code class="docutils literal notranslate"><span class="pre">printf</span></code> 风格的字符串格式化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#binary-sequence-types-bytes-bytearray-memoryview">二进制序列类型 --- <code class="docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="docutils literal notranslate"><span class="pre">memoryview</span></code></a><ul>
<li><a class="reference internal" href="#bytes-objects">bytes 对象</a></li>
<li><a class="reference internal" href="#bytearray-objects">bytearray 对象</a></li>
<li><a class="reference internal" href="#bytes-and-bytearray-operations">bytes 和 bytearray 操作</a></li>
<li><a class="reference internal" href="#printf-style-bytes-formatting"><code class="docutils literal notranslate"><span class="pre">printf</span></code>-style Bytes Formatting</a></li>
<li><a class="reference internal" href="#memory-views">Memory Views</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-types-set-frozenset">集合类型 --- <code class="docutils literal notranslate"><span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">frozenset</span></code></a></li>
<li><a class="reference internal" href="#mapping-types-dict">映射类型 --- <code class="docutils literal notranslate"><span class="pre">dict</span></code></a><ul>
<li><a class="reference internal" href="#dictionary-view-objects">Dictionary view objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-manager-types">Context Manager Types</a></li>
<li><a class="reference internal" href="#other-built-in-types">Other Built-in Types</a><ul>
<li><a class="reference internal" href="#modules">模块</a></li>
<li><a class="reference internal" href="#classes-and-class-instances">Classes and Class Instances</a></li>
<li><a class="reference internal" href="#functions">函数</a></li>
<li><a class="reference internal" href="#methods">方法</a></li>
<li><a class="reference internal" href="#code-objects">代码对象</a></li>
<li><a class="reference internal" href="#type-objects">Type 对象</a></li>
<li><a class="reference internal" href="#the-null-object">The Null Object</a></li>
<li><a class="reference internal" href="#the-ellipsis-object">The Ellipsis Object</a></li>
<li><a class="reference internal" href="#the-notimplemented-object">The NotImplemented Object</a></li>
<li><a class="reference internal" href="#boolean-values">布尔值</a></li>
<li><a class="reference internal" href="#internal-objects">Internal Objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-attributes">特殊属性</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="constants.html" tppabs="https://docs.python.org/zh-cn/3/library/constants.html"
                        title="上一章">内置常量</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="exceptions.html" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html"
                        title="下一章">内置异常</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html" tppabs="https://docs.python.org/zh-cn/3/bugs.html">提交 Bug</a></li>
      <li>
        <a href="javascript:if(confirm('https://github.com/python/cpython/blob/3.7/Doc/library/stdtypes.rst  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/python/cpython/blob/3.7/Doc/library/stdtypes.rst'" tppabs="https://github.com/python/cpython/blob/3.7/Doc/library/stdtypes.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" tppabs="https://docs.python.org/zh-cn/3/genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="py-modindex.html" tppabs="https://docs.python.org/zh-cn/3/py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="exceptions.html" tppabs="https://docs.python.org/zh-cn/3/library/exceptions.html" title="内置异常"
             >下一页</a> |</li>
        <li class="right" >
          <a href="constants.html" tppabs="https://docs.python.org/zh-cn/3/library/constants.html" title="内置常量"
             >上一页</a> |</li>
        <li><img src="py.png" tppabs="https://docs.python.org/zh-cn/3/_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="javascript:if(confirm('https://www.python.org/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://www.python.org/'" tppabs="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh_CN</span>
          <span class="version_switcher_placeholder">3.7.3</span>
          <a href="index-11.html" tppabs="https://docs.python.org/zh-cn/3/index.html">文档</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index-2.html" tppabs="https://docs.python.org/zh-cn/3/library/index.html" >Python 标准库</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="https://docs.python.org/zh-cn/3/search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="copyright.html" tppabs="https://docs.python.org/zh-cn/3/copyright.html">版权所有</a> 2001-2019, Python Software Foundation.
    <br />
    Python 软件基金会是一个非盈利组织。
    <a href="javascript:if(confirm('https://www.python.org/psf/donations/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://www.python.org/psf/donations/'" tppabs="https://www.python.org/psf/donations/">请捐助。</a>
    <br />
    最后更新于 4月 22, 2019.
    <a href="bugs.html" tppabs="https://docs.python.org/zh-cn/3/bugs.html">发现了问题</a>？
    <br />
    使用<a href="javascript:if(confirm('http://sphinx.pocoo.org/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://sphinx.pocoo.org/'" tppabs="http://sphinx.pocoo.org/">Sphinx</a>1.8.4 创建。
    </div>

  </body>
</html>